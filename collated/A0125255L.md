# A0125255L
###### \src\main\logic\Add.java
``` java

public class Add implements Command {
	
	private static final String MSG_SUCCESS_ADD = "Added new %1$s task \"%2$s\".";
	private static final String MSG_SUCCESS_UNDO = "Undid previous command.";
	private static final String MSG_SUCCESS_REDO = "Redid previous command.";
	private static final String MSG_FAIL_INVALID_RECUR_FREQ = "Error: Invalid recurring frequency entered.";
	private static final String MSG_FAIL_FILE_SAVE = "Error: File could not be saved after add command.";
	
	private static final String TYPE_DEADLINE = "deadline";
	private static final String TYPE_EVENT = "event";
	private static final String TYPE_FLOATING = "floating";
	private static final String TYPE_RECURRING = "recurring";
	
	private static final int RECUR_TYPE_DAILY = 1;
	private static final int RECUR_TYPE_WEEKLY = 2;
	private static final int RECUR_TYPE_MONTHLY = 3;
	private static final int RECUR_TYPE_YEARLY = 4;
	
	private UserInput userInput;
	private static Storage storage;
	private static Feedback feedback;
	private ArrayList<Task> taskList;
	private ArrayList<Task> recurList;
	
	private static Logger logger = Logger.getLogger("Add");

	/**
	 * Constructs an Add command
	 * @param userInput: userInput instance from MainLogic
	 */
	public Add(UserInput userInput) {
		this.userInput = userInput;
		storage = Storage.getInstance();
		feedback = Feedback.getInstance();
		taskList = new ArrayList<Task>();
		recurList = new ArrayList<Task>();
	}

	/**
	 * Executes the command
	 */
	@Override
	public void execute() {
		logger.log(Level.INFO, "Command ADD");
		taskList = storage.getTaskList();
		Task task = userInput.getTask();
		if (task.isRecurring()) {
			if (task.getRecurTime() <= 0) {
				feedback.setMessage(MSG_FAIL_INVALID_RECUR_FREQ);
				return;
			}
			task.setHead(task);
			Task newTask = Task.duplicateTask(task);
			recurList.add(newTask);
			taskList.add(newTask);
			task.setRecurTime(task.getRecurTime() - 1);
			Calendar calStart = Calendar.getInstance();
			Calendar calEnd = Calendar.getInstance();
			while (task.getRecurTime() > 0) {
				updateDate(task, calStart, calEnd);
				generateRecurTasks(task, calStart, calEnd);
				updateList(task);
			}
			
			task.setRecurList(recurList);	
		}
		
		else {
			if (task.getTaskStartDate() != null && 
					(task.getTaskStartDate().compareTo(MainLogic.getCurrentDate()) < 0)) {
				task.setExpired(true);
			}
			taskList.add(task);
		}
		
		if (!storage.saveFile()) {
			feedback.setMessage(MSG_FAIL_FILE_SAVE);
		}
		else {
			feedback.setMessage(String.format(MSG_SUCCESS_ADD, getTaskTypeString(), userInput.getTask().getTaskDetails()));
		}
	}

	/**
	 * Updates the taskList and recurList to the list of all recurring tasks
	 * @param task: Task to be added to the list
	 */
	private void updateList(Task task) {
		Task newTask;
		newTask = Task.duplicateTask(task);
		recurList.add(newTask);
		taskList.add(newTask);
	}

	/**
	 * Updates the date for the recurring task
	 * @param task: Task to be updated
	 * @param calStart: Start date of task
	 * @param calEnd: End date of task
	 */
	private void updateDate(Task task, Calendar calStart, Calendar calEnd) {
		task.setRecurTime(task.getRecurTime() - 1);
		Date dateStart = task.getTaskStartDate();
		calStart.set(dateStart.getYear(), dateStart.getMonth(), dateStart.getDay());
		Date dateEnd;
		if (task.getTaskEndDate() != null) {
			dateEnd = task.getTaskEndDate();
			calEnd.set(dateEnd.getYear(), dateEnd.getMonth(), dateEnd.getDay());
		}
	}

	/**
	 * Creates an instance after updating the new recurring date
	 * @param task: Task to update the date to
	 * @param calStart: Start date of task
	 * @param calEnd: End date of task
	 */
	private void generateRecurTasks(Task task, Calendar calStart, Calendar calEnd) {
		switch (task.getRecurFrequency()) {
		case RECUR_TYPE_DAILY: {	//daily
			calStart.add(Calendar.DAY_OF_MONTH, 1);
			calEnd.add(Calendar.DAY_OF_MONTH, 1);
			task.setTaskStartDate(new Date(calStart.get(Calendar.DAY_OF_MONTH), 
												calStart.get(Calendar.MONTH), 
													calStart.get(Calendar.YEAR)));
			if (task.getTaskEndDate() != null) {
				task.setTaskEndDate(new Date(calEnd.get(Calendar.DAY_OF_MONTH), 
						calEnd.get(Calendar.MONTH), 
							calEnd.get(Calendar.YEAR)));
			}
			break;
		}
		case RECUR_TYPE_WEEKLY: {	//weekly
			calStart.add(Calendar.DAY_OF_MONTH, 7);
			calEnd.add(Calendar.DAY_OF_MONTH, 7);
			task.setTaskStartDate(new Date(calStart.get(Calendar.DAY_OF_MONTH), 
												calStart.get(Calendar.MONTH), 
													calStart.get(Calendar.YEAR)));
			if (task.getTaskEndDate() != null) {
				task.setTaskEndDate(new Date(calEnd.get(Calendar.DAY_OF_MONTH), 
						calEnd.get(Calendar.MONTH), 
							calEnd.get(Calendar.YEAR)));
			}
			break;
		}
		case RECUR_TYPE_MONTHLY: {	//monthly
			calStart.add(Calendar.MONTH, 1);
			calEnd.add(Calendar.MONTH, 1);
			task.setTaskStartDate(new Date(calStart.get(Calendar.DAY_OF_MONTH), 
												calStart.get(Calendar.MONTH), 
													calStart.get(Calendar.YEAR)));
			if (task.getTaskEndDate() != null) {
				task.setTaskEndDate(new Date(calEnd.get(Calendar.DAY_OF_MONTH), 
						calEnd.get(Calendar.MONTH), 
							calEnd.get(Calendar.YEAR)));
			}
			break;
		}
		case RECUR_TYPE_YEARLY: {	//yearly
			calStart.add(Calendar.YEAR, 1);
			calEnd.add(Calendar.YEAR, 1);
			task.setTaskStartDate(new Date(calStart.get(Calendar.DAY_OF_MONTH), 
												calStart.get(Calendar.MONTH), 
													calStart.get(Calendar.YEAR)));
			if (task.getTaskEndDate() != null) {
				task.setTaskEndDate(new Date(calEnd.get(Calendar.DAY_OF_MONTH), 
						calEnd.get(Calendar.MONTH), 
							calEnd.get(Calendar.YEAR)));
			}
			break;
		}
		}
	}
	
```
###### \src\main\logic\Add.java
``` java
	/**
	 * Undo the command
	 */
	@Override
	public void undo() {
		logger.log(Level.INFO, "Command UNDO ADD");
		taskList = storage.getTaskList();
		if (userInput.getTask().isRecurring()) {
			for (int i=0; i<userInput.getTask().getRecurList().size(); i++) {
				Task t = userInput.getTask().getRecurList().get(i);
				taskList.remove(t);
			}
		}
		
		else {
			taskList.remove(userInput.getTask());
		}
		storage.saveFile();
		
		feedback.setMessage(MSG_SUCCESS_UNDO);
	}

	/**
	 * Redo the command
	 */
	@Override
	public void redo() {
		logger.log(Level.INFO, "Command REDO ADD");
		taskList = storage.getTaskList();
		if (userInput.getTask().isRecurring()) {
			for (int i=0; i<userInput.getTask().getRecurList().size(); i++) {
				Task t = userInput.getTask().getRecurList().get(i);
				taskList.add(t);
			}
		}
		
		else {
			taskList.add(userInput.getTask());
		}
		storage.saveFile();
		
		feedback.setMessage(MSG_SUCCESS_REDO);
	}

}
```
###### \src\main\logic\AddTest.java
``` java
public class AddTest {
	
	UserInput userInput;
	Command command;
	ArrayList<Task> taskList;
	Storage storage;
	Task task;
	
	private static File file;
	private static final String FILE_NAME = "testFile.dat";
	
	@Test
	public void test() {
		taskList = new ArrayList<Task>();
		file = new File(FILE_NAME);
		
		if (file.exists()) {
			file.delete();
		}
		
		Storage.setFileName(FILE_NAME);
		storage = Storage.getInstance();	
		
		
		//Adding floating task "test1" to the taskList
		task = new Task("floating task", "test1", 1);
		userInput = new UserInput("add test1");
		userInput.setTask(task);
		command = new Add(userInput);
		command.execute();
		taskList.add(task);
		assertEquals(taskList, storage.getTaskList());
		
		//Adding deadline task "test2" to the taskList
		task = new Task("deadline task", "test2", 2);
		userInput = new UserInput("add test2");
		userInput.setTask(task);
		command = new Add(userInput);
		command.execute();
		taskList.add(task);
		assertEquals(taskList, storage.getTaskList());
		
		//Adding event task "test3" to the taskList
		task = new Task("event task", "test3", 3);
		userInput = new UserInput("add test3");
		userInput.setTask(task);
		command = new Add(userInput);
		command.execute();
		taskList.add(task);
		assertEquals(taskList, storage.getTaskList());
		
		if (file.exists()) {
			file.delete();
		}
	}

}
```
###### \src\main\logic\Command.java
``` java

public interface Command {

	/**
	 * Executes the command
	 */
	public void execute();
	
	/**
	 * Undo the command
	 */
	public void undo();
	
	/**
	 * Redo the command
	 */
	public void redo();
}
```
###### \src\main\logic\Complete.java
``` java

public class Complete implements Command {

	//Feedback Strings
	private static final String MSG_SUCCESS_COMPLETE = "Task completed.";
	private static final String MSG_SUCCESS_UNCOMPLETE = "Task uncompleted.";
	private static final String MSG_SUCCESS_UNDO = "Undid previous command.";
	private static final String MSG_SUCCESS_REDO = "Redid previous command.";
	private static final String MSG_FAIL_TASK_COMPLETED = "Error: Task is already completed.";
	private static final String MSG_FAIL_TASK_UNCOMPLETED = "Error: Task is not completed.";
	private static final String MSG_FAIL_INDEX_OOB = "Error: The specified task could not be found.;";

	private UserInput userInput;
	private static Storage storage;
	private static Feedback feedback;
	private ArrayList<Task> taskList;

	private static Logger logger = Logger.getLogger("Complete");
	private static boolean COMPLETE = true;
	private static boolean INCOMPLETE = false;

	/**
	 * Constructs a Complete command
	 * @param userInput: userInput instance from MainLogic
	 */
	public Complete(UserInput userInput) {
		this.userInput = userInput;
		storage = Storage.getInstance();
		feedback = Feedback.getInstance();
		taskList = new ArrayList<Task>();
	}
	
	/**
	 * Executes the command
	 */
	@Override
	public void execute() {
		boolean done = false;

		logger.log(Level.INFO, "Command COMPLETE");
		taskList = storage.getTaskList();
		for (int i=0; i<userInput.getTasksToDelete().size(); i++) {
			Task taskToMark = userInput.getTasksToDelete().get(i);
			for (Task t: taskList) {
				if (taskToMark.equals(t)) {
					if (userInput.getComplete() == COMPLETE) {
						if (!t.isComplete()) {
							t.setComplete(COMPLETE);
							taskToMark.setComplete(COMPLETE);
							feedback.setMessage(MSG_SUCCESS_COMPLETE);
							done = true;
						}
						else {
							feedback.setMessage(MSG_FAIL_TASK_COMPLETED);
							done = true;
						}
					}
					else {
						if (t.isComplete()) {
							t.setComplete(INCOMPLETE);
							taskToMark.setComplete(INCOMPLETE);
							feedback.setMessage(MSG_SUCCESS_UNCOMPLETE);
							done = true;
						}
						else {
							feedback.setMessage(MSG_FAIL_TASK_UNCOMPLETED);
							done = true;
						}
					}
				}
			}
			
			if (!done) {
				feedback.setMessage(MSG_FAIL_INDEX_OOB);
			}
		}
	}

	/**
	 * Undo the command
	 */
	@Override
	public void undo() {
		logger.log(Level.INFO, "Command COMPLETE UNDO");
		taskList = storage.getTaskList();
		for (int i=0; i<userInput.getTasksToDelete().size(); i++) {
			Task taskToMark = userInput.getTasksToDelete().get(i);
			for (Task t: taskList) {
				if (taskToMark.equals(t)) {
					if (userInput.getComplete() == COMPLETE) {
						t.setComplete(INCOMPLETE);
						taskToMark.setComplete(INCOMPLETE);
					}

					else {
						t.setComplete(COMPLETE);
						taskToMark.setComplete(COMPLETE);
					}
				}
			}
		}
		
		feedback.setMessage(MSG_SUCCESS_UNDO);

	}

	/**
	 * Redo the command
	 */
	@Override
	public void redo() {
		logger.log(Level.INFO, "Command COMPLETE REDO");
		taskList = storage.getTaskList();
		for (int i=0; i<userInput.getTasksToDelete().size(); i++) {
			Task taskToMark = userInput.getTasksToDelete().get(i);
			for (Task t: taskList) {
				if (taskToMark.equals(t)) {
					if (userInput.getComplete() == COMPLETE) {
						t.setComplete(COMPLETE);
						taskToMark.setComplete(COMPLETE);
					}

					else {
						t.setComplete(INCOMPLETE);
						taskToMark.setComplete(INCOMPLETE);
					}
				}
			}
		}
storage.saveFile();
		
		feedback.setMessage(MSG_SUCCESS_REDO);
	}
}
```
###### \src\main\logic\CompleteTest.java
``` java
public class CompleteTest {

	UserInput userInput;
	Command command;
	ArrayList<Task> taskList;
	ArrayList<Task> completeList;
	Storage storage;
	Task task;
	
	private static File file;
	private static final String FILE_NAME = "testFile.dat";
	
	@Test
	public void test() {
		taskList = new ArrayList<Task>();
		completeList = new ArrayList<Task>();
		file = new File(FILE_NAME);
		
		if (file.exists()) {
			file.delete();
		}
		
		Storage.setFileName(FILE_NAME);
		storage = Storage.getInstance();	
		
		//Adding floating task "test1" to the taskList
		task = new Task("floating task", "test1", 1);
		userInput = new UserInput("add test1");
		userInput.setTask(task);
		command = new Add(userInput);
		command.execute();
		taskList.add(task);
		
		//Adding deadline task "test2" to the taskList
		task = new Task("deadline task", "test2", 2);
		userInput = new UserInput("add test2");
		userInput.setTask(task);
		command = new Add(userInput);
		command.execute();
		taskList.add(task);
		
		//Adding event task "test3" to the taskList
		task = new Task("event task", "test3", 3);
		userInput = new UserInput("add test3");
		userInput.setTask(task);
		command = new Add(userInput);
		command.execute();
		taskList.add(task);
		
		
		//Mark "test1" as complete
		userInput = new UserInput("mark f1");
		userInput.setComplete(true);
		command = new Complete(userInput);
		completeList.add(new Task("floating task", "test1", 1));
		userInput.setTaskToDelete(completeList);
		command.execute();
		taskList.get(0).setComplete(true);
		assertEquals(taskList, storage.getTaskList());
		
		//Mark "test1" as incomplete
		userInput = new UserInput("uncomplete f1");
		userInput.setComplete(false);
		command = new Complete(userInput);
		completeList.add(new Task("floating task", "test1", 1));
		userInput.setTaskToDelete(completeList);
		command.execute();
		taskList.get(0).setComplete(false);
		assertEquals(taskList, storage.getTaskList());
		
		
		if (file.exists()) {
			file.delete();
		}
	}
}
```
###### \src\main\logic\Delete.java
``` java

public class Delete implements Command {


	private static final String MSG_SUCCESS_DELETE = "Deleted %1$s task %2$d.";
	private static final String MSG_SUCCESS_DELETE_MULTIPLE = "Deleted multiple tasks.";
	private static final String MSG_SUCCESS_UNDO = "Undid previous command.";
	private static final String MSG_SUCCESS_REDO = "Redid previous command.";
	private static final String MSG_FAIL_INDEX_OOB = "Error: No such %1$s task with index %2$d.";
	private static final String MSG_FAIL_INDEX_OOB_MULTIPLE = "Error: At least one invalid index entered.";
	private static final String MSG_FAIL_FILE_SAVE = "Error: File could not be saved after delete command.";

	private static final String TYPE_DEADLINE = "deadline";
	private static final String TYPE_EVENT = "event";
	private static final String TYPE_FLOATING = "floating";


	private UserInput userInput;
	private static Storage storage;
	private static Feedback feedback;
	private ArrayList<Task> taskList;
	private static Logger logger = Logger.getLogger("Delete");

	/**
	 * Constructs a Delete command
	 * @param userInput: userInput instance from MainLogic
	 */
	public Delete(UserInput userInput) {
		this.userInput = userInput;
		storage = Storage.getInstance();
		feedback = Feedback.getInstance();
		taskList = new ArrayList<Task>();
	}

	/**
	 * Execute the command
	 */
	@Override
	public void execute() {
		boolean success = false;

		logger.log(Level.INFO, "Command DELETE");
		taskList = storage.getTaskList();
		ArrayList<Task> displayList = MainLogic.getDisplayList();

		Task task = null;
		
		for (int i=0; i<userInput.getTasksToDelete().size(); i++) {
			task = userInput.getTasksToDelete().get(i);
			if (task.isRecurring() && userInput.getIsAll()) {
				Task t = task.getHead();
				for (int j=0; j<t.getRecurList().size(); j++) {
					taskList.remove(t.getRecurList().get(j));
					displayList.remove(t.getRecurList().get(j));
				}
				userInput.setRecurList(t.getRecurList());
				t.setRecurList(new ArrayList<Task>());
			}
			
			else if (task.isRecurring()) {
				taskList.remove(task);
				displayList.remove(task);
				Task t = task.getHead();
				t.getRecurList().remove(task);
			}
			
			else {
				taskList.remove(task);
				displayList.remove(task);
			}
		}

		success = true;

		if (!storage.saveFile()) {
			feedback.setMessage(MSG_FAIL_FILE_SAVE);
		}
		else if (success) {
			if (userInput.getDeleteNumber().size() > 1) {
				feedback.setMessage(MSG_SUCCESS_DELETE_MULTIPLE);
			}
			else {
				feedback.setMessage(String.format(MSG_SUCCESS_DELETE, getTaskTypeString(task), userInput.getDeleteNumber().get(0)[1]));
			}
		}
		else {
			if (userInput.getDeleteNumber().size() > 1) {
				feedback.setMessage(MSG_FAIL_INDEX_OOB_MULTIPLE);;
			}
			else {
				feedback.setMessage(String.format(MSG_FAIL_INDEX_OOB, getTaskTypeString(task), userInput.getDeleteNumber().get(0)[1]));
			}
		}
	}
	
```
###### \src\main\logic\Delete.java
``` java
	/**
	 * Undo the command
	 */
	@Override
	public void undo() {
		logger.log(Level.INFO, "Command UNDO DELETE");
		taskList = storage.getTaskList();
		ArrayList<Task> displayList = MainLogic.getDisplayList();
		for (int i=0; i<userInput.getTasksToDelete().size(); i++) {
			Task task = userInput.getTasksToDelete().get(i);
			
			if (task.isRecurring() && userInput.getIsAll()) {
				Task t = task.getHead();
				for (int j=0; j<userInput.getRecurList().size(); j++) {
					taskList.add(userInput.getRecurList().get(j));
					if (!displayList.equals(taskList)) {
						displayList.add(userInput.getRecurList().get(j));
					}
				}
				t.setRecurList(userInput.getRecurList());
			}
			
			else if (task.isRecurring()) {
				taskList.add(task);
				if (!displayList.equals(taskList)) {
					displayList.add(task);
				}
				Task t = task.getHead();
				t.getRecurList().add(task);
			}
			
			else {
				taskList.add(task);
				if (!displayList.equals(taskList)) {
					displayList.add(task);
				}
			}
		}
		storage.saveFile();

		feedback.setMessage(MSG_SUCCESS_UNDO);
	}

	/**
	 * Redo the command
	 */
	@Override
	public void redo() {
		logger.log(Level.INFO, "Command REDO DELETE");
		taskList = storage.getTaskList();
		ArrayList<Task> displayList = MainLogic.getDisplayList();
		for (int i=0; i<userInput.getTasksToDelete().size(); i++) {
			Task task = userInput.getTasksToDelete().get(i);
			
			if (task.isRecurring() && userInput.getIsAll()) {
				Task t = task.getHead();
				for (int j=0; j<t.getRecurList().size(); j++) {
					taskList.remove(t.getRecurList().get(j));
					displayList.remove(t.getRecurList().get(j));
				}
				userInput.setRecurList(t.getRecurList());
				t.setRecurList(new ArrayList<Task>());
			}
			
			else if (task.isRecurring()) {
				taskList.remove(task);
				displayList.remove(task);
				Task t = task.getHead();
				t.getRecurList().remove(task);
			}
			
			else {
				taskList.remove(task);
				displayList.remove(task);
			}
		}
		storage.saveFile();

		feedback.setMessage(MSG_SUCCESS_REDO);
	}
}
```
###### \src\main\logic\DeleteTest.java
``` java
public class DeleteTest {

	UserInput userInput;
	Command command;
	ArrayList<Task> taskList;
	ArrayList<Task> deleteList;
	Storage storage;
	Task task;
	
	private static File file;
	private static final String FILE_NAME = "testFile.dat";
	
	@Test
	public void test() {
		taskList = new ArrayList<Task>();
		deleteList = new ArrayList<Task>();
		file = new File(FILE_NAME);
		
		if (file.exists()) {
			file.delete();
		}
		
		Storage.setFileName(FILE_NAME);
		storage = Storage.getInstance();	
		
		//Adding floating task "test1" to the taskList
		task = new Task("floating task", "test1", 1);
		userInput = new UserInput("add test1");
		userInput.setTask(task);
		command = new Add(userInput);
		command.execute();
		taskList.add(task);
		
		//Adding deadline task "test2" to the taskList
		task = new Task("deadline task", "test2", 2);
		userInput = new UserInput("add test2");
		userInput.setTask(task);
		command = new Add(userInput);
		command.execute();
		taskList.add(task);
		
		//Adding event task "test3" to the taskList
		task = new Task("event task", "test3", 3);
		userInput = new UserInput("add test3");
		userInput.setTask(task);
		command = new Add(userInput);
		command.execute();
		taskList.add(task);
		
		//Delete "test1" from the taskList
		userInput = new UserInput("delete d1");
		deleteList.add(new Task("floating task", "test1", 1));
		userInput.setTaskToDelete(deleteList);
		MainLogic.run(userInput);
		command = new Delete(userInput);
		command.execute();
		taskList.remove(new Task("floating task", "test1", 1));
		assertEquals(taskList, storage.getTaskList());
		
		//Delete "test2" and "test3" from the taskList
		userInput = new UserInput("delete d1 d2");
		deleteList.add(new Task("deadline task", "test2", 2));
		deleteList.add(new Task("event task", "test3", 3));
		userInput.setTaskToDelete(deleteList);
		MainLogic.run(userInput);
		command = new Delete(userInput);
		command.execute();
		taskList.remove(new Task("deadline task", "test2", 2));
		taskList.remove(new Task("event task", "test3", 3));
		assertEquals(taskList, storage.getTaskList());
		
		if (file.exists()) {
			file.delete();
		}
	}
}
```
###### \src\main\logic\Display.java
``` java

public class Display implements Command {
	
	UserInput userInput;
	Storage storage;
	static Logger logger = Logger.getLogger("Display");

	/**
	 * Constructs a Display command
	 * @param userInput: userInput instance from MainLogic
	 */
	public Display(UserInput userInput) {
		this.userInput = userInput;
		storage = Storage.getInstance();
	}


	/**
	 * Execute the command
	 */
	@Override
	public void execute() {
		logger.log(Level.INFO, "Command DISPLAY");
		Command command = new Sort(userInput);
		command.execute();
		storage.saveFile();		
	}

	@Override
	public void undo() {
		//do nothing
		
	}

	@Override
	public void redo() {
		//do nothing	
	}

}
```
###### \src\main\logic\Edit.java
``` java

public class Edit implements Command {

	private static final String MSG_SUCCESS_EDIT = "Editted task successfully.";
	private static final String MSG_SUCCESS_UNDO = "Undid previous command.";
	private static final String MSG_SUCCESS_REDO = "Redid previous command.";
	private static final String MSG_INVALID_EDIT_TYPE = "Error: Invalid edit category.";
	private static final String MSG_FAIL_NO_START_DATE = "Error: Cannot add end date to floating task without start date.";
	private static final String MSG_FAIL_NO_START_TIME = "Error: Cannot add end time to floating task without start time.";
	private static final String MSG_FAIL_FILE_SAVE = "Error: File could not be saved after edit command.";
	private static final String MSG_FAIL_INVALID_DATE = "Error: Invalid date/time entered.";
	private static final String MSG_FAIL_START_DATE_LATER_THAN_END_DATE = "Error: End date/time is earlier than start date/time";

	private static final int EDIT_TASK_DETAIL = 1;
	private static final int EDIT_TASK_START_DATE = 2;
	private static final int EDIT_TASK_START_TIME = 3;
	private static final int EDIT_TASK_END_DATE = 4;
	private static final int EDIT_TASK_END_TIME = 5;
	private static final int EDIT_TASK_LOCATION = 6;
	private static final int EDIT_TASK_PRIORITY = 7;
	private static final int EDIT_TASK_COMPLETE = 8;

	private UserInput userInput;
	private static Storage storage;
	private static Feedback feedback;
	private ArrayList<Task> taskList;
	private ArrayList<Task> recurList;
	private static Logger logger = Logger.getLogger("Edit");

	/**
	 * Constructs an Edit command
	 * @param userInput: UserInput instance from MainLogic
	 */
	public Edit(UserInput userInput) {
		this.userInput = userInput;
		storage = Storage.getInstance();
		feedback = Feedback.getInstance();
		taskList = new ArrayList<Task>();
		recurList = new ArrayList<Task>();
	}	

	/**
	 * Execute the command
	 */
	@Override
	public void execute() {
		boolean success = false;
		boolean changedTaskType = false;
		logger.log(Level.INFO, "Command EDIT");
		taskList = storage.getTaskList();
		ArrayList<Task> displayList = MainLogic.getDisplayList();
		Task taskToEdit = userInput.getTaskToEdit();
		userInput.setTaskToEdit(taskToEdit);
		Task newTask = null;


		if (taskToEdit.isRecurring() && userInput.getIsAll()) {
			Task t = taskToEdit.getHead();
			userInput.setRecurList(t.getRecurList());
			for (int i=0; i<t.getRecurList().size(); i++) {
				newTask = Task.duplicateTask(t.getRecurList().get(i));
				editTask(success, changedTaskType, displayList, t.getRecurList().get(i), newTask);
			}
			userInput.setTask(taskToEdit);
			t.setRecurList(recurList);
		}

		else if (taskToEdit.isRecurring()) {
			newTask = Task.duplicateTask(taskToEdit);
			editTask(success, changedTaskType, displayList, taskToEdit, newTask);
			userInput.setTask(newTask);
			taskToEdit.getHead().getRecurList().remove(taskToEdit);
			taskToEdit.getHead().getRecurList().add(newTask);
		}

		else {
			newTask = Task.duplicateTask(taskToEdit);
			editTask(success, changedTaskType, displayList, taskToEdit, newTask);
			userInput.setTask(newTask);
		}

		Date startDate = newTask.getTaskStartDate();
		Time startTime = newTask.getTaskStartTime();
		Date endDate = newTask.getTaskEndDate();
		Time endTime = newTask.getTaskEndTime();

		if (userInput.getStartDate().isValid()) {
			startDate = userInput.getStartDate();
		}
		if (userInput.getStartTime().isValid()) {
			startTime = userInput.getStartTime();
		}
		if (userInput.getEndDate() .isValid()) {
			endDate = userInput.getEndDate();
		}
		if (userInput.getEndTime().isValid()) {
			endTime = userInput.getEndTime();
		}

		if (!isValidDateAndTime(startDate, startTime, endDate, endTime)) {
			feedback.setMessage(MSG_FAIL_INVALID_DATE);
			return;
		}
		if (isEndDateEarlierThanStartDate(startDate, startTime, endDate, endTime)) {
			feedback.setMessage(MSG_FAIL_START_DATE_LATER_THAN_END_DATE);
			return;
		}
	}

	/**
	 * Executes the task edit
	 * @param success: returns true if editTask runs without error
	 * @param changedTaskType: returns true if taskType is changed previously
	 * @param displayList: displayList from MainLogic
	 * @param taskToEdit: Task to be edited
	 * @param newTask: Task to change to
	 */
	private void editTask(boolean success, boolean changedTaskType, ArrayList<Task> displayList, Task taskToEdit,
			Task newTask) {
		for (int i=1; i<userInput.getEditNumber().size(); i++) {
			switch (userInput.getEditNumber().get(i)) {
			case EDIT_TASK_DETAIL:	{	//task detail
				newTask.setTaskDetails(userInput.getDetails());
				success = true;
				break;
			}

			case EDIT_TASK_START_DATE: {	//task start date
				if (newTask.getTaskType() == 2) {	//floating
					if (!changedTaskType) {
						changedTaskType = true;
					}
					newTask.setTaskType(4);	//deadline
				}
				newTask.setTaskStartDate(userInput.getStartDate());
				success = true;
				break;
			}

			case EDIT_TASK_START_TIME:	{	//task start time
				if (newTask.getTaskType() == 2) {	//floating
					if (!changedTaskType) {
						changedTaskType = true;
					}
					newTask.setTaskType(4);	//deadline
				}
				newTask.setTaskStartTime(userInput.getStartTime());
				success = true;
				break;
			}
			case EDIT_TASK_END_DATE:	{	//task end date		
				if (newTask.getTaskType() == 2) { //floating
					feedback.setMessage(MSG_FAIL_NO_START_DATE);
					break;
				}
				if (newTask.getTaskType() == 4) {	//deadline
					if (!changedTaskType) {
						changedTaskType = true;
					}
					newTask.setTaskType(1);	//event
				}
				newTask.setTaskEndDate(userInput.getEndDate());

				success = true;
				break;
			}
			case EDIT_TASK_END_TIME:	{	//task end time
				if (newTask.getTaskType() == 2) { //floating
					feedback.setMessage(MSG_FAIL_NO_START_TIME);
					break;
				}
				if (newTask.getTaskType() == 4) {	//deadline
					if (!changedTaskType) {
						changedTaskType = true;
					}
					newTask.setTaskType(1);	//event
				}
				newTask.setTaskEndTime(userInput.getEndTime());
				success = true;
				break;
			}
			case EDIT_TASK_LOCATION: {	//task location
				newTask.setTaskLocation(userInput.getLocation());
				success = true;
				break;
			}
			case EDIT_TASK_PRIORITY:	{	//task priority
				newTask.setPriority(userInput.getPriority());
				success = true;
				break;
			}
			case EDIT_TASK_COMPLETE: {	//is complete			
				newTask.setComplete(userInput.getComplete());
				success = true;
				break;
			}
			default:
				feedback.setMessage(MSG_INVALID_EDIT_TYPE);
				return;
			}


			if (!storage.saveFile()) {
				feedback.setMessage(MSG_FAIL_FILE_SAVE);
			}
			else if (success) {
				feedback.setMessage(String.format(MSG_SUCCESS_EDIT));
			}
		}

		recurList.add(newTask);
		taskList.remove(taskToEdit);
		taskList.add(newTask);
		if (!displayList.equals(taskList)) {
			displayList.remove(taskToEdit);
			displayList.add(newTask);
		}
	}

```
###### \src\main\logic\Edit.java
``` java
	/**
	 * Undo the command
	 */
	@Override
	public void undo() {
		logger.log(Level.INFO, "Command UNDO EDIT");
		taskList = storage.getTaskList();
		ArrayList<Task> displayList = MainLogic.getDisplayList();

		if (userInput.getTask().isRecurring() && userInput.getIsAll()) {
			Task t = userInput.getTask().getHead();
			for (int i=0; i<t.getRecurList().size(); i++) {
				taskList.remove(t.getRecurList().get(i));
				taskList.add(userInput.getRecurList().get(i));
				if (!displayList.equals(taskList)) {
					displayList.remove(t.getRecurList().get(i));
					displayList.add(userInput.getRecurList().get(i));
				}
			}

			ArrayList<Task> swapList = userInput.getRecurList();
			userInput.setRecurList(t.getRecurList());
			t.setRecurList(swapList);
		}
		else {
			taskList.remove(userInput.getTask());
			taskList.add(userInput.getTaskToEdit());
			if (!displayList.equals(taskList)) {
				displayList.remove(userInput.getTask());
				displayList.add(userInput.getTaskToEdit());
			}		
		}
		storage.saveFile();
		
		feedback.setMessage(MSG_SUCCESS_UNDO);
	}

	/**
	 * Redo the command
	 */
	@Override
	public void redo() {
		logger.log(Level.INFO, "Command REDO EDIT");
		taskList = storage.getTaskList();
		ArrayList<Task> displayList = MainLogic.getDisplayList();

		if (userInput.getTask().isRecurring() && userInput.getIsAll()) {
			Task t = userInput.getTask().getHead();
			for (int i=0; i<t.getRecurList().size(); i++) {
				taskList.remove(t.getRecurList().get(i));
				taskList.add(userInput.getRecurList().get(i));
				if (!displayList.equals(taskList)) {
					displayList.remove(t.getRecurList().get(i));
					displayList.add(userInput.getRecurList().get(i));
				}
			}

			ArrayList<Task> swapList = userInput.getRecurList();
			userInput.setRecurList(t.getRecurList());
			t.setRecurList(swapList);
		}
		else {
			taskList.remove(userInput.getTaskToEdit());
			taskList.add(userInput.getTask());
			if (!displayList.equals(taskList)) {
				displayList.remove(userInput.getTaskToEdit());
				displayList.add(userInput.getTask());
			}

			
		}
		storage.saveFile();
		
		feedback.setMessage(MSG_SUCCESS_REDO);
	}
}
```
###### \src\main\logic\EditTest.java
``` java
public class EditTest {

	UserInput userInput;
	Command command;
	ArrayList<Task> taskList;
	ArrayList<Integer> editList;
	Storage storage;
	Task task;
	
	private static File file;
	private static final String FILE_NAME = "testFile.dat";
	
	@Test
	public void test() {
		taskList = new ArrayList<Task>();
		editList = new ArrayList<Integer>();
		file = new File(FILE_NAME);
		
		if (file.exists()) {
			file.delete();
		}
		
		Storage.setFileName(FILE_NAME);
		storage = Storage.getInstance();	
		
		//Adding deadline task "test1" to the taskList
		task = new Task("deadline task", "test1", 2);
		userInput = new UserInput("add test2");
		userInput.setTask(task);
		command = new Add(userInput);
		command.execute();
		taskList.add(task);
		
		//Edit location of "test1" from the taskList
		userInput = new UserInput("edit d1");
		userInput.setLocation("location1");
		editList.add(1);	//task number
		editList.add(6); 	//location tag
		System.out.println("editlist "+editList.size());
		userInput.setEdit(editList);
		userInput.setTaskToEdit(task);
		MainLogic.setDisplayList(new ArrayList<Task>());
		command = new Edit(userInput);
		command.execute();
		taskList = new ArrayList<Task>();
		taskList.add(userInput.getTask());
		assertEquals(taskList, storage.getTaskList());
			
		if (file.exists()) {
			file.delete();
		}
	}
}
```
###### \src\main\logic\MainLogic.java
``` java

public class MainLogic {

	//-----Variables-----

	//Feedback Strings
	private static final String MSG_FAIL_INVALID_DATE = "Error: Invalid date/time entered.";
	private static final String MSG_FAIL_START_DATE_LATER_THAN_END_DATE = "Error: End date/time is earlier than start date/time";
	private static final int EVENT = 1;
	private static final int FLOATING = 2;
	private static final int DEADLINE = 4;
	private static final int SORT_TYPE_DATE = 2;

	//Global Variables
	private static Storage storage;
	private static Feedback feedback;
	private static ArrayList<Task> taskList;
	private static ArrayList<Task> displayList;
	private static Command command;
	private static UserInput userInput;
	private static MainLogic mainLogic;
	private static int sortType;
	private static Stack<Command> commandList;
	private static Stack<Command> undoedCommandList;
	private static Date currentDate;
	private static Time currentTime;
	private static boolean success;

	static Logger logger = Logger.getLogger("MainLogic");

	//-----Constructor-----
	/**
	 * Creates an instance of MainLogic and initializes variables
	 */
	public MainLogic() {
		//Initialize variables
		storage = Storage.getInstance();
		feedback = Feedback.getInstance();
		updateTaskList();
		setDisplayList(taskList);
		sortType = SORT_TYPE_DATE;
		commandList = new Stack<Command>();
		undoedCommandList = new Stack<Command>();
		currentDate = null;
		currentTime = null;
	}

	/**
	 * Runs the MainLogic
	 * throws exception if any component fails to complete
	 * @param input: Default UserInput object containing only raw data
	 */
	public static void run(UserInput input) {
		logger.log(Level.INFO, "MainLogic START");
		success = true;
		try {
			initializeMainLogic();
			setUserInput(input);
			runParser();
			createCommandObject();
			executeCommand();
			updateTaskList();
			logger.log(Level.INFO, "MainLogic END");
		} catch (Exception e) {
			logger.log(Level.WARNING, "MainLogic ERROR");
			success = false;
		}
	}

	//-----Private methods-----
	/**
	 * Creates a Command object with the respective command type
	 * @throws Exception for invalid date
	 */
	private static void createCommandObject() throws Exception {
		if (!isValidDateAndTime()) {
			feedback.setMessage(MSG_FAIL_INVALID_DATE);
			throw new Exception("Invalid date format");
		}
		if (isEndDateEarlierThanStartDate()) {
			feedback.setMessage(MSG_FAIL_START_DATE_LATER_THAN_END_DATE);
			throw new Exception("End date/time is earlier than start date/time");
		}

		switch (getCommand()) {
		case "add": {
			addCommand();		
			break;
		}
		case "delete": {
			deleteCommand();
			break;
		}
		case "edit": {
			editCommand();
			break;
		}

		case "display": {
			displayCommand();
			break;
		}

		case "sort": {
			sortCommand();
			break;
		}

		case "search": {
			searchCommand();
			break;
		}

		case "recurring": {
			addCommand();
			break;
		}

		case "home": {
			homeCommand();
			break;
		}

		case "undo": {
			undoCommand();
			break;
		}

		case "redo": {
			redoCommand();
			break;
		}

		case "import": {
			importCommand();
			break;
		}

		case "export": {
			exportCommand();
			break;
		}

		case "complete": {
			completeCommand();
			break;
		}

		case "uncomplete": {
			completeCommand();
			break;
		}

		default: {
			defaultSearch();
			break;
		}
		}
	}

	/**
	 * Creates the "Add" command object
	 * Push the Object to the commandList
	 */
	private static void addCommand() {
		command = new Add(userInput);
		commandList.push(command);
		clearUndoStack();
		displayList = storage.getTaskList();
	}

	/**
	 * Creates the "Delete" command object
	 * Push the Object to the commandList
	 */
	private static void deleteCommand() {
		userInput.setTaskToDelete(findDeleteTask());
		command = new Delete(userInput);
		commandList.push(command);
		clearUndoStack();
	}

	/**
	 * Creates the "Edit" command object
	 * Push the Object to the commandList
	 */
	private static void editCommand() {
		userInput.setTaskToEdit(findEditTask());
		command = new Edit(userInput);
		commandList.push(command);
		clearUndoStack();
	}

	/**
	 * Creates the "Display" command object
	 * Sets the display sort type to be the current sort structure
	 */
	private static void displayCommand() {
		userInput.setSortType(sortType);
		command = new Display(userInput);
	}

	/**
	 * Creates the "Sort" command object
	 * Sets the sortType to the new sort structure
	 */
	private static void sortCommand() {
		command = new Sort(userInput);
		sortType = userInput.getSortType();
	}


	/**
	 * Creates the "Search" command object
	 */
	private static void searchCommand() {
		command = new Search(userInput);
	}

	/**
	 * Sets the displayList to the default storage taskList
	 * copyList(): new instance of storage taskList
	 */
	private static void homeCommand() {
		displayList = storage.getTaskList();
	}

	/**
	 * Undo the last executed Command object
	 * Removes the Object from the commandList and pushes the object to the
	 * undoedCommandList for redoing purposes
	 */
	private static void undoCommand() {
		if (!commandList.empty()) {
			Command command = commandList.pop();
			undoedCommandList.push(command);
			command.undo();
		}
	}

	/**
	 * Redo the last undone Command object
	 * Removes the Object from the undoedCommandList and pushes the object to 
	 * the commandList for undoing purposes
	 */
	private static void redoCommand() {
		if (!undoedCommandList.empty()) {
			Command command = undoedCommandList.pop();
			commandList.push(command);
			command.redo();
		}
	}

	/**
	 * Imports the file through the file path given
	 */
	private static void importCommand() {
		storage.importFile(userInput.getPath());
		displayList = storage.getTaskList();
	}

	/**
	 * Exports the file through the file path given
	 */
	private static void exportCommand() {
		storage.exportFile(userInput.getPath());
	}

	/**
	 * Creates the "Complete" command object
	 * Push the Object to the commandList
	 */
	private static void completeCommand() {
		userInput.setTaskToDelete(completeTask());
		command = new Complete(userInput);
		commandList.push(command);
		clearUndoStack();
		displayList = storage.getTaskList();
	}

	/**
	 * Sets the default command to be search term
	 * Creates the "Search" command object
	 */
	private static void defaultSearch() {
		userInput.setSearchTerm(userInput.getCommand());
		searchCommand();
	}

```
###### \src\main\logic\MainLogic.java
``` java
	/**
	 * Calls the constructor of MainLogic if it doesn't exist
	 */
	private static void initializeMainLogic() {
		if (mainLogic == null) {
			MainLogic.createMainLogic();
		}
	}

	/**
	 * Sets the local userInput variable to the current userInput
	 * @param input: the userInput variable from TaskOverviewController
	 */
	private static void setUserInput(UserInput input) {
		userInput = input;
	}

	/**
	 * Updates the new userInput variable with parameters from Parser
	 */
	private static void runParser() {
		userInput = Parser.resetUserInput(userInput);
	}

	/**
	 * Executes the command object instance if it is not null 
	 */
	private static void executeCommand() {
		command.execute();
	}

	/**
	 * Updates the local variable taskList after Command object execution 
	 */
	private static void updateTaskList() {
		taskList = storage.getTaskList();
	}

	/**
	 * Gets the command intended by the input string from TaskOverviewController
	 * @return String object of Command type
	 */
	private static String getCommand() {
		return Shortcuts.shortcuts(userInput.getCommand().toLowerCase());
	}

	/**
	 * Clears the undo Command stack
	 */
	private static void clearUndoStack() {
		undoedCommandList = new Stack<Command>();
	}

	/**
	 * Searches for the Task object the user intend to edit
	 * @return Task if task is present in list
	 */
	private static Task findEditTask() {
		int count = 0;
		//ArrayList<Task> list = new ArrayList<Task>();
		for (int i=0; i<getList().size(); i++) {
			Task task = getList().get(i);
			if (task.getTaskType() == userInput.getTaskType()) {
				count++;
				if(count == userInput.getEditNumber().get(0)) {
					return task;
				}
			}
		}

		return null;
	}

	/**
	 * Searches all the Tasks the user intend to delete
	 * @return ArrayList of Tasks if Task is present in list
	 */
	private static ArrayList<Task> findDeleteTask() {
		int count;
		ArrayList<Task> list = new ArrayList<Task>();
		int taskType = 0;
		int taskNumber = 0;

		for (int i=0; i<userInput.getDeleteNumber().size(); i++) {
			count = 0;
			taskType = userInput.getDeleteNumber().get(i)[0];
			taskNumber = userInput.getDeleteNumber().get(i)[1];

			for (int j=0; j<getList().size(); j++) {
				Task task = getList().get(j);
				if (task.getTaskType() == taskType) {
					count++;
					if(count == taskNumber) {
						list.add(task);
					}
				}
			}
		}

		return list;
	}

	/**
	 * Searches the Tasks the user intend to complete/uncomplete
	 * @return ArrayList of Tasks if Tasks is present in list
	 */
	private static ArrayList<Task> completeTask() {
		int count;
		int taskType = 0;
		int taskNumber = 0;
		ArrayList<Task> list = new ArrayList<Task>();;
		for (int i=0; i<userInput.getDeleteNumber().size(); i++) {
			count = 0;
			taskType = userInput.getDeleteNumber().get(i)[0];
			taskNumber = userInput.getDeleteNumber().get(i)[1];

			for (int j=0; j<getList().size(); j++) {
				Task task = getList().get(j);
				if (task.getTaskType() == taskType) {
					count++;
					if(count == taskNumber) {
						list.add(task);
					}
				}
			}
		}

		return list;
	}

	/**
	 * Gets and sets the local currentTime variable to the console time
	 */
	private static void setCurrentTime() {
		Calendar cal = Calendar.getInstance();
		int hour = cal.get(Calendar.HOUR_OF_DAY);
		int minute = cal.get(Calendar.MINUTE);
		currentTime = new Time(hour, minute);   
	}

	/**
	 * Gets and sets the local currentDate variable to the console date
	 */
	private static void setCurrentDate() {
		Calendar cal = Calendar.getInstance();
		int year = cal.get(Calendar.YEAR);
		int month = cal.get(Calendar.MONTH) + 1;
		int day = cal.get(Calendar.DAY_OF_MONTH);
		currentDate = new Date(day, month, year);
	}

	/**
	 * Creates a mainLogic instance
	 */
	private static void createMainLogic() {
		mainLogic = new MainLogic();
	}

	/**
	 * Gets the current taskList user is viewing from
	 * @return ArrayList of Task user is currently viewing
	 */
	private static ArrayList<Task> getList() {
		switch (userInput.getTab()) {
		case 1: {	//All
			return getTaskListUnfiltered();
		}
		case 2: {	//Today
			return getTodayTasksUnfiltered();
		}
		case 3: {	//Upcoming
			return getWeekTasksUnfiltered();
		}
		case 4: {	//Complete
			return getCompletedTasksUnfiltered();
		}
		case 5: {	//Overdue/Expired
			return getExpiredTasksUnfiltered();
		}
		default: {
			return null;
		}
		}
	}


	//-----Public Methods-----
	/**
	 * Sets the current time and returns the Time object
	 * @return Time object of current time
	 */
	public static Time getCurrentTime() {
		setCurrentTime();
		return currentTime;
	}

	/**
	 * Sets the current date and returns the Date object
	 * @return return Date object of current date
	 */
	public static Date getCurrentDate() {
		setCurrentDate();
		return currentDate;
	}

	/**
	 * Gets the current day
	 * @return String representation of current day
	 */
	public static String getCurrentDay() {
		Calendar cal = Calendar.getInstance();
		String[] days = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", 
				"Friday", "Saturday"};
		return days[cal.get(Calendar.DAY_OF_WEEK) - 1];
	}

	/**
	 * Checks if the MainLogic runs to the end without errors
	 * @return true if successful
	 */
	public static boolean isSuccessful() {
		return success;
	}

	/**
	 * Sets the displayList to a newList
	 * @param newList: list to change the displayList to
	 */
	public static void setDisplayList(ArrayList<Task> newList) {
		displayList = newList;
	}

	/**
	 * Gets the current displayList
	 * @return ArrayList of Task of current displayList
	 */
	public static ArrayList<Task> getDisplayList() {
		return displayList;
	}

	/**
	 * Filters the given list to 3 different components: Deadline, Floating, Event
	 * @param list: list to be filtered
	 * @return ArrayList of ArrayList of Task Object of filtered components
	 */
	private static ArrayList<ArrayList<Task>> getFilteredList(ArrayList<Task> list) {
		ArrayList<ArrayList<Task>> newList = new ArrayList<ArrayList<Task>>();
		ArrayList<Task> eventList = new ArrayList<Task>();
		ArrayList<Task> floatList = new ArrayList<Task>();
		ArrayList<Task> deadlineList = new ArrayList<Task>();
		setCurrentDate();
		setCurrentTime();

		for (int i=0; i<list.size(); i++) {
			Task task = checkExpired(list, i);
			filterTask(eventList, floatList, deadlineList, task);
		}

		createList(newList, eventList, floatList, deadlineList);
		return newList;
	}

	/**
	 * Creates the list containing: Deadline, Floating, Event
	 * @param newList: List to be created
	 * @param eventList: Event list
	 * @param floatList: Float list
	 * @param deadlineList: Deadline list
	 */
	private static void createList(ArrayList<ArrayList<Task>> newList, ArrayList<Task> eventList,
			ArrayList<Task> floatList, ArrayList<Task> deadlineList) {
		newList.add(eventList);
		newList.add(floatList);
		newList.add(deadlineList);
		storage.saveFile();
	}

	/**
	 * Filter the task into the respective Deadline, Floating, Event lists
	 * @param eventList: Event list
	 * @param floatList: Float list
	 * @param deadlineList: Deadline list
	 * @param task: Task to be added
	 */
	private static void filterTask(ArrayList<Task> eventList, ArrayList<Task> floatList, ArrayList<Task> deadlineList,
			Task task) {
		switch (task.getTaskType()) {
		case EVENT: {	//event
			eventList.add(task);
			break;
		}
		case FLOATING: {	//floating
			floatList.add(task);
			break;
		}
		case DEADLINE: {	//deadline
			deadlineList.add(task);
			break;
		}
		}
	}

	/**
	 * Check whether the task is expired
	 * @param list: taskList from Storage
	 * @param i: Task object position in list
	 * @return Task object after determining whether to toggle expired variable
	 */
	private static Task checkExpired(ArrayList<Task> list, int i) {
		Task task = list.get(i);
		if (task.getTaskStartDate() != null && task.getTaskStartDate().compareTo(currentDate) < 0) {
			task.setExpired(true);
		}

		else if (task.getTaskStartDate() != null &&
				task.getTaskStartDate().compareTo(currentDate) == 0 && 
				task.getTaskStartTime() != null && 
				task.getTaskStartTime().compareTo(currentTime) < 0) {
			task.setExpired(true);
		}

		else {
			task.setExpired(false);
		}
		return task;
	}

	//Lists
	/**
	 * Gets the filtered "All" taskList
	 * @return ArrayList of ArrayList of Tasks of filtered list
	 */
	public static ArrayList<ArrayList<Task>> getTaskList() {
		return getFilteredList(getTaskListUnfiltered());
	}

	/**
	 * Gets the filtered "Completed" taskList
	 * @return ArrayList of ArrayList of Tasks of filtered list
	 */
	public static ArrayList<ArrayList<Task>> getCompletedTasks() {
		return getFilteredList(getCompletedTasksUnfiltered());
	}

	/**
	 * Gets the filtered "Today" taskList
	 * @return ArrayList of ArrayList of Tasks of filtered list
	 */
	public static ArrayList<ArrayList<Task>> getTodayTasks() {
		return getFilteredList(getTodayTasksUnfiltered());
	}

	/**
	 * Gets the filtered "Expired" taskList
	 * @return ArrayList of ArrayList of Tasks of filtered list
	 */
	public static ArrayList<ArrayList<Task>> getExpiredTasks() {
		return getFilteredList(getExpiredTasksUnfiltered());
	}

	/**
	 * Gets the filtered "Upcoming" taskList
	 * @return ArrayList of ArrayList of Tasks of filtered list
	 */
	public static ArrayList<ArrayList<Task>> getWeekTasks() {
		return getFilteredList(getWeekTasksUnfiltered());
	}

	/**
	 * Gets the unfiltered "All" taskList
	 * @return ArrayList of Tasks of unfiltered list
	 */
	public static ArrayList<Task> getTaskListUnfiltered() {
		ArrayList<Task> list = new ArrayList<Task>();
		for (int i=0 ;i<displayList.size(); i++) {
			Task task = displayList.get(i);
			if (!task.isComplete()) {
				list.add(task);
			}
		}
		return list;
	}

	/**
	 * Gets the unfiltered "Completed" taskList
	 * @return ArrayList of Tasks of unfiltered list
	 */
	public static ArrayList<Task> getCompletedTasksUnfiltered() {
		ArrayList<Task> list = new ArrayList<Task>();
		for (int i=0 ;i<displayList.size(); i++) {
			Task task = displayList.get(i);
			if (task.isComplete()) {
				list.add(task);
			}
		}
		return list;
	}

	/**
	 * Gets the unfiltered "Today" taskList
	 * @return ArrayList of Tasks of unfiltered list
	 */
	public static ArrayList<Task> getTodayTasksUnfiltered() {
		ArrayList<Task> list = new ArrayList<Task>();
		for (int i=0 ;i<displayList.size(); i++) {
			Task task = displayList.get(i);
			if ((task.getTaskStartDate() != null && 
					(task.getTaskStartDate().compareTo(getCurrentDate()) == 0) &&
					!task.isComplete()) ||
					task.getTaskType() == FLOATING) {
				list.add(task);
			}
		}

		return list;
	}

	/**
	 * Gets the unfiltered "Expired" taskList
	 * @return ArrayList of Tasks of unfiltered list
	 */
	public static ArrayList<Task> getExpiredTasksUnfiltered() {
		ArrayList<Task> list = new ArrayList<Task>();
		for (int i=0 ;i<displayList.size(); i++) {
			Task task = displayList.get(i);
			if ((task.isExpired() || task.getTaskType() == FLOATING) && !task.isComplete()) {
				list.add(task);
			}
		}

		return list;
	}

	/**
	 * Gets the unfiltered "Upcoming" taskList
	 * @return ArrayList of Tasks of unfiltered list
	 */
	public static ArrayList<Task> getWeekTasksUnfiltered() {
		ArrayList<Task> list = new ArrayList<Task>();
		Calendar cal = Calendar.getInstance();
		cal.add(Calendar.DAY_OF_MONTH, 7);
		Date date = new Date(cal.get(Calendar.DAY_OF_MONTH), cal.get(Calendar.MONTH) + 1, cal.get(Calendar.YEAR));
		for (int i=0 ;i<displayList.size(); i++) {
			Task task = displayList.get(i);
			if ((task.getTaskStartDate() != null &&
					((task.getTaskStartDate().compareTo(getCurrentDate()) >= 0) && 
							(task.getTaskStartDate().compareTo(date) < 0)) &&
					!task.isComplete()) ||
					task.getTaskType() == FLOATING) {				
				list.add(task);
			}
		}

		return list;
	}
}
```
###### \src\main\logic\Search.java
``` java

public class Search implements Command {
	
	private static final String MSG_SUCCESS_SEARCH = "Searching for text containing \"%1$s\".";
	private static final String MSG_FAIL_NO_SEARCH_TERM = "Error: No search term entered.";
	
	private UserInput userInput;
	private static Storage storage;
	private static Feedback feedback;
	private static Logger logger = Logger.getLogger("Search");

	/**
	 * Constructs a Search command
	 * @param userInput: userInput instance from MainLogic
	 */
	public Search(UserInput userInput) {
		this.userInput = userInput;
		storage = Storage.getInstance();
		feedback = Feedback.getInstance();
		new ArrayList<Task>();
	}

	/**
	 * Execute the command
	 */
	@Override
	public void execute() {
		logger.log(Level.INFO, "Command SEARCH");
		if (userInput.getSearchTerm().length() == 0) {
			userInput.setTaskList(storage.getTaskList());
			feedback.setMessage(MSG_FAIL_NO_SEARCH_TERM);
		}
		
		else {
			ArrayList<Task> searchResults = new ArrayList<Task>();
			String searchTerm = userInput.getSearchTerm().toLowerCase();
			for (Task t : storage.getTaskList()) {
				if (t.getTaskLocation() != null && t.getTaskLocation().toLowerCase().contains(searchTerm)) {
					searchResults.add(t);
				}
				
				else if (t.getTaskDetails() != null && t.getTaskDetails().toLowerCase().contains(searchTerm)) {
					searchResults.add(t);
				}
				
				else if (t.getTaskLocation() != null && t.getTaskLocation().toLowerCase().contains(searchTerm)) {
					searchResults.add(t);
				}
				
				else if (t.getTaskStartTime() != null && t.getTaskStartTime().getTimeString().contains(searchTerm)) {
					searchResults.add(t);
				}
				
				else if (t.getTaskEndTime() != null && t.getTaskEndTime().getTimeString().contains(searchTerm)) {
					searchResults.add(t);
				}
				
				else if (t.getTaskStartDate() != null && t.getTaskStartDate().getDateString().contains(searchTerm)) {
					searchResults.add(t);
				}
				
				else if (t.getTaskEndDate() != null && t.getTaskEndDate().getDateString().contains(searchTerm)) {
					searchResults.add(t);
				}			
			}
			
			MainLogic.setDisplayList(searchResults);
			feedback.setMessage(String.format(MSG_SUCCESS_SEARCH, userInput.getSearchTerm()));
		}
	}

	@Override
	public void undo() {
		
	}

	@Override
	public void redo() {
		
	}

}
```
###### \src\main\logic\Sort.java
``` java

public class Sort implements Command {

	private static final String MSG_SUCCESS_SORT = "Sorted tasks by %1$s.";
	private static final String MSG_FAIL_INVALID_SORT_TYPE = "Error: \"%1$s\" is an invalid sort category.";

	private static final String TYPE_DETAIL = "details";
	private static final String TYPE_START_DATE = "date";
	private static final String TYPE_START_TIME = "time";
	private static final String TYPE_LOCATION = "location";
	private static final String TYPE_PRIORITY = "priority";
	
	private static final int SORT_TYPE_DETAILS = 1;
	private static final int SORT_TYPE_DATE = 2;
	private static final int SORT_TYPE_TIME = 3;
	private static final int SORT_TYPE_LOCATION = 6;
	private static final int SORT_TYPE_PRIORITY = 7;

	private UserInput userInput;
	private static Storage storage;
	private static Feedback feedback;
	private ArrayList<Task> taskList;
	private static Logger logger = Logger.getLogger("Sort");

	/**
	 * Constructs a Sort command
	 * @param userInput: userInput instance from MainLogic
	 */
	public Sort(UserInput userInput) {
		this.userInput = userInput;
		storage = Storage.getInstance();
		feedback = Feedback.getInstance();
		taskList = new ArrayList<Task>();
	}

	/**
	 * Executes the command
	 */
	@Override
	public void execute() {
		logger.log(Level.INFO, "Command SORT");
		taskList = storage.getTaskList();
		ArrayList<Task> displayList = MainLogic.getDisplayList();
		switch (userInput.getSortType()) {
		case SORT_TYPE_DETAILS:	//task details
			Collections.sort(taskList, new TaskComparator(SORT_TYPE_DETAILS));
			Collections.sort(displayList, new TaskComparator(SORT_TYPE_DETAILS));
			break;

		case SORT_TYPE_DATE:	//task date
			Collections.sort(taskList, new TaskComparator(SORT_TYPE_DATE));
			Collections.sort(displayList, new TaskComparator(SORT_TYPE_DATE));
			break;

		case SORT_TYPE_TIME:	//task time
			Collections.sort(taskList, new TaskComparator(SORT_TYPE_TIME));
			Collections.sort(displayList, new TaskComparator(SORT_TYPE_TIME));
			break;

		case SORT_TYPE_LOCATION:	//task location
			Collections.sort(taskList, new TaskComparator(SORT_TYPE_LOCATION));
			Collections.sort(displayList, new TaskComparator(SORT_TYPE_LOCATION));
			break;

		case SORT_TYPE_PRIORITY:	//task priority
			Collections.sort(taskList, new TaskComparator(SORT_TYPE_PRIORITY));
			Collections.sort(displayList, new TaskComparator(SORT_TYPE_PRIORITY));
			break;

		default:
			feedback.setMessage(String.format(MSG_FAIL_INVALID_SORT_TYPE, feedback.getSortString()));
			return;
		}
		feedback.setMessage(String.format(MSG_SUCCESS_SORT, getSortCategoryString()));

		storage.saveFile();
		MainLogic.setDisplayList(displayList);

		userInput.setTaskList(taskList);
	}

```
###### \src\main\logic\Sort.java
``` java
	@Override
	public void undo() {
		// TODO Auto-generated method stub

	}

	@Override
	public void redo() {
		// TODO Auto-generated method stub

	}

}
```
###### \src\main\resources\TaskComparator.java
``` java

public class TaskComparator implements Comparator<Task> {
	
	private static final int SORT_TYPE_DETAILS = 1;
	private static final int SORT_TYPE_DATE = 2;
	private static final int SORT_TYPE_TIME = 3;
	private static final int SORT_TYPE_LOCATION = 6;
	private static final int SORT_TYPE_PRIORITY = 7;
	
	int compareType;
	
	/**
	 * Constructs a TaskComparator
	 * @param type: sortType from MainLogic
	 */
	public TaskComparator(int type) {
		compareType = type;
	}

	/**
	 * Compare method for Comparator
	 * @param task0, task1: tasks to be compared
	 * @return int: Integer value of compare result
	 */
	@Override
	public int compare(Task task0, Task task1) {
		switch (compareType) {
		case SORT_TYPE_DETAILS: {	//task details
			if (task0.getTaskDetails() == null) {
				return 1;
			}
			
			else if (task1.getTaskDetails() == null) {
				return -1;
			}
			
			else if (!task0.getTaskDetails().equals(task1.getTaskDetails())) {
				return task0.getTaskDetails().compareTo(task1.getTaskDetails());
			}
			
			else {
				return task0.getPriority() - task1.getPriority();
			}
		}
		case SORT_TYPE_DATE: {	//task date
			if (task0.getTaskStartDate() == null && 
					task1.getTaskStartDate() == null) {
				return task0.getTaskDetails().compareTo(task1.getTaskDetails());
			}
			
			else if (task0.getTaskStartDate() == null) {
				return 1;
			}
			
			else if (task1.getTaskStartDate() == null) {
				return -1;
			}
			
			else if (!task0.getTaskStartDate().equals(task1.getTaskStartDate())) {
				return task0.getTaskStartDate().compareTo(task1.getTaskStartDate());
			}
			
			else if (task0.getTaskStartTime() == null &&
						task1.getTaskStartTime() == null) {
				return task0.getTaskDetails().compareTo(task1.getTaskDetails());
			}
			
			else if (task0.getTaskStartTime() == null) {
				return 1;
			}
			
			else if (task1.getTaskStartTime() == null) {
				return -1;
			}
			
			else {
				return task0.getTaskStartTime().compareTo(task1.getTaskStartTime());
			}
		}
		case SORT_TYPE_TIME: {	//task time
			if (task0.getTaskStartTime() == null && 
					task1.getTaskStartTime() == null) {
				return task0.getTaskDetails().compareTo(task1.getTaskDetails());
			}
			
			else if (task0.getTaskStartTime() == null) {
				return 1;
			}
			
			else if (task1.getTaskStartTime() == null) {
				return -1;
			}
			
			else if (!task0.getTaskStartTime().equals(task1.getTaskStartTime())) {
				return task0.getTaskStartTime().compareTo(task1.getTaskStartTime());
			}
			
			
			
			else {
				return task0.getTaskDetails().compareTo(task1.getTaskDetails());
			}
		}
		case SORT_TYPE_LOCATION: {	//task location
			if (task0.getTaskLocation() == null && 
					task1.getTaskLocation() == null) {
				return task0.getTaskDetails().compareTo(task1.getTaskDetails());
			}
			
			else if (task0.getTaskLocation()== null) {
				return 1;
			}
			
			else if (task1.getTaskLocation() == null) {
				return -1;
			}
			
			else if (!task0.getTaskLocation().equals(task1.getTaskLocation())) {
				return task0.getTaskLocation().compareTo(task1.getTaskLocation());
			}
			
			else {
				return task0.getTaskDetails().compareTo(task1.getTaskDetails());
			}
		}
		case SORT_TYPE_PRIORITY: { 	//task priority
			if (task0.getPriority() != task1.getPriority()) {
				return task0.getPriority() - task1.getPriority();	
			}
			
			else if (task0.getTaskStartDate() == null && 
					task1.getTaskStartDate() == null) {
				return task0.getTaskDetails().compareTo(task1.getTaskDetails());
			}
			
			else if (task0.getTaskStartDate() == null) {
				return 1;
			}
			
			else if (task1.getTaskStartDate() == null) {
				return -1;
			}
			
			else if (!task0.getTaskStartDate().equals(task1.getTaskStartDate())) {
				return task0.getTaskStartDate().compareTo(task1.getTaskStartDate());
			}
			
			else if (task0.getTaskStartTime() == null && task1.getTaskStartTime() == null) {
				return task0.getTaskDetails().compareTo(task1.getTaskDetails());
			}
			
			else if (task0.getTaskStartTime() == null) {
				return 1;
			}
			
			else if (task1.getTaskStartTime() == null) {
				return -1;
			}
			
			else if (!task0.getTaskStartTime().equals(task1.getTaskStartTime())) {
				return task0.getTaskStartTime().compareTo(task1.getTaskStartTime());
			}
			
			else {
				return task0.getTaskDetails().compareTo(task1.getTaskDetails());
			}
		}
		default: {
			
		}
		}
		
		return 0;
	}

}
```
###### \src\main\resources\TaskComparatorTest.java
``` java
public class TaskComparatorTest {
 
    @Test
    public void test() {
        TaskComparator comparator;
        Task task1 = new Task();
        Task task2 = new Task();
        int compareResult = 0;
        
        //Details test
        comparator = new TaskComparator(1);
        task1.setTaskDetails("abc");
        task2.setTaskDetails("xyz");
        compareResult = comparator.compare(task1,  task2);
        assertTrue(compareResult < 0);
        
        //Start Date test
        comparator = new TaskComparator(2);
        task1.setTaskStartDate(new Date(1,1,01));
        task2.setTaskStartDate(new Date(2,2,02));
        compareResult = comparator.compare(task1,  task2);
        assertTrue(compareResult < 0);
        
        //Start Time test
        comparator = new TaskComparator(3);
        task1.setTaskStartTime(new Time(12, 00));
        task2.setTaskStartTime(new Time(13, 00));
        compareResult = comparator.compare(task1,  task2);
        assertTrue(compareResult < 0);
        
        //Location test
        comparator = new TaskComparator(6);
        task1.setTaskLocation("abc");
        task2.setTaskLocation("xyz");
        compareResult = comparator.compare(task1,  task2);
        assertTrue(compareResult < 0);
        
        //Priority test
        comparator = new TaskComparator(7);
        task1.setPriority(1);
        task2.setPriority(3);
        compareResult = comparator.compare(task1,  task2);
        assertTrue(compareResult < 0);
        
        
    }
 
}
```
###### \src\main\resources\UserInput.java
``` java

public class UserInput {
	
	String rawInput;
	String command;
	int tab;//1 for first tab, 2 for second tab etc.
	boolean isAll;//for edit and delete recurring task
	
	//Add
	Task task;
	
	
	int taskType; //1-Event, 2-Floating, 3-Recurring 4-Deadline
	ArrayList<Task> recurList;
	boolean displaySort;
	
	//Delete
	ArrayList<int[]> deleteNumber;
	ArrayList<Task> taskToDelete;
	
	//Edit
	ArrayList<Integer> editNumber;
	Time startTime;
	Date startDate;
	Time endTime;
	Date endDate;
	String location;
	String details;
	boolean complete;
	int priority;
	Task taskToEdit;
	
	//Search and sort
	String searchTerm;
	int sortType;
	ArrayList<Task> taskList;
	
	//set 
	String path;
	
	//Constructors
	public UserInput(String raw) {
		rawInput = raw;
		startTime = new Time();
		startDate = new Date();
		endTime = new Time();
		endDate = new Date();
		details = null;
		command = null;
		task = null;
		deleteNumber = new ArrayList<int[]>();
		editNumber = new ArrayList<Integer> ();
		location = null;
		sortType = -1;
		searchTerm = null;
		taskList = new ArrayList<Task>();
		priority = 0;
		taskType = -1;
		complete = false;
		isAll = false;
		displaySort = false;
		recurList = null;
	}
	
	public UserInput(String raw, int tab) {
		this.tab = tab;
		rawInput = raw;
		startTime = new Time();
		startDate = new Date();
		endTime = new Time();
		endDate = new Date();
		details = null;
		command = null;
		task = null;
		deleteNumber = new ArrayList<int[]>();
		editNumber = new ArrayList<Integer> ();
		location = null;
		sortType = -1;
		searchTerm = null;
		taskList = new ArrayList<Task>();
		priority = 0;
		taskType = -1;
		complete = false;
		displaySort = false;
		recurList = null;
	}
	
	
	//Getters
	public boolean getComplete(){
		return complete;
	}
	
	public boolean getIsAll(){
		return isAll;
	}
	
	public int getTaskType(){
		return taskType;
	}
	
	public String getRawInput() {
		return rawInput;
	}
	
	public String getDetails() {
		return details;
	}
	
	public int getPriority() {
		return priority ;
	}
	
	public String getCommand() {
		return command;
	}
	
	public Task getTask() {
		return task;
	}
	
	public ArrayList<int[]> getDeleteNumber() {
		return deleteNumber;
	}
	
	public ArrayList<Integer> getEditNumber() {
		return editNumber;
	}
	

	public String getLocation() {
		return location;
	}
	
	public Time getStartTime(){
		return startTime;
	}
	
	public Date getStartDate(){
		return startDate;
	}
	
	public Time getEndTime(){
		return endTime;
	}
	
	public Date getEndDate(){
		return endDate;
	}
	
	public String getSearchTerm() {
		return searchTerm;
	}
	
	public int getSortType() {
		return sortType;
	}
	
	public ArrayList<Task> getTaskList() {
		return taskList;
	}
	
	public String getPath(){
		return path;
	}
	
	public ArrayList<Task> getTasksToDelete() {
		return taskToDelete;
	}
	
	public Task getTaskToEdit() {
		return taskToEdit;
	}

	public int getTab() {
		return tab;
	}
	
	public ArrayList<Task> getRecurList() {
		return recurList;
	}
	
	
	//Setters
	public void setIsAll(boolean a){
		isAll = a;
	}
	
	public void setPath(String path){
		this.path = path;
	}
	
	public void setComplete(boolean c){
		complete = c;
	}
	
	
	public void setRawInput(String input) {
		this.rawInput = input;
	}
	
	public void setTaskType(int deleteType){
		this.taskType = deleteType;
	}
	
	public void setCommand(String command) {
		this.command = command;
	}
	
	public void setDetails(String details) {
		this.details = details;
	}
	
	public void setTask(Task task) {
		this.task = task;
	}
	
	public void setDeleteNumber(ArrayList<int[]> list) {
		deleteNumber = list;
	}
	
	public void setEdit(ArrayList<Integer> list) {
		editNumber = list;
	}
	
	public void setLocation(String location){
		this.location=location;
	}
	
	public void setStartDate(Date date){
		this.startDate=date;
	}
	
	public void setStartTime(Time time) {
		this.startTime = time;
	}
	
	public void setEndDate(Date date){
		this.endDate=date;
	}
	
	public void setEndTime(Time time) {
		this.endTime = time;
	}
	
	public void setSearchTerm(String term) {
		searchTerm = term;
	}
	
	public void setPriority(int priority) {
		this.priority = priority;
	}
	
	public void setSortType(int type) {
		sortType = type;
	}
	
	public void setTaskList(ArrayList<Task> taskList) {
		this.taskList = taskList;
	}
	
	public void setTaskToEdit(Task task2) {
		taskToEdit = task2;
	}

	public void setTaskToDelete(ArrayList<Task> list) {
		taskToDelete = list;
	}

	public void setDisplaySort(boolean displaySort) {
		this.displaySort = displaySort;
	}
	
	public void setRecurList(ArrayList<Task> list) {
		recurList = list;
	}
}
```
