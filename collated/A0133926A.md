# A0133926A
###### \src\main\parser\CreateTask.java
``` java

public class CreateTask {
	private static final String FROM = "from";
	private static final String BY = "by";
	private static final String TO = "to";
	private static final String AT = "at";
	private static final String PRIORITY = "-p";
	private static final String DAILY = "daily";
	private static final String WEEKLY = "weekly";
	private static final String MONTHLY = "monthly";
	private static final String YEARLY = "yearly";
	private static final String FOR = "for";
	private static final String MIDNIGHT = "midnight";
	private static final String NOON = "noon";
	private static final String TOMORROW = "tomorrow";
	private static final String TODAY = "today";
	private static final String MONDAY = "monday";
	private static final String TUESDAY = "tuesday";
	private static final String WEDNESDAY = "wednesday";
	private static final String THURSDAY = "thursday";
	private static final String FRIDAY = "friday";
	private static final String SATURDAY = "saturday";
	private static final String SUNDAY = "sunday";
	private static final String JANUARY = "January";
	private static final String FEBRUARY = "February";
	private static final String MARCH = "March";
	private static final String APRIL = "April";
	private static final String MAY = "May";
	private static final String JUNE = "June";
	private static final String JULY = "July";
	private static final String AUGUST = "August";
	private static final String SEPTEMBER = "September";
	private static final String OCTOBER = "October";
	private static final String NOVEMBER = "November";
	private static final String DECEMBER = "December";
	
	//Feedback strings
	//private static final String MSG_FAIL_INVALID_PRIORITY = "Error: \"%1$s\" is an invalid priority.";
	
	//private static Feedback feedback = Feedback.getInstance();


	

	/**
	 * Creates a Task object of type "deadline"
	 * @param taskType: Task type of task
	 * @param info: Information to be added to the Task object
	 * @return Task object of the created task
	 */
	public final static Task createDeadline(String taskType, ArrayList<String> info) {
		String taskName = taskType + " task";
		Task task = new Task();
		int indexOfBy = info.indexOf(BY);
		int length = info.size();
		int indexOfP = 0;

		indexOfP = setPriorityForDeadlineTask(info, task, length);

		String detail = getDetail(info, 1, indexOfBy);
		String dateAndTime = info.get(indexOfBy + 1);
		setLocationForDeadlineTask(info, taskName, task, indexOfP, detail, dateAndTime);
		return task;
	}

	/**
	 * assign location,start time, start date, task details to deadline task
	 * Sets the location for the deadline task
	 * @param info : ArrayList containing each word of the user input.
	 * @param taskName : string containing task name.
	 * @param task : the Task object.
	 * @param indexOfP : int index of keyword "-p"
	 * @param detail : string containing task details.
	 * @param dateAndTime : string containing the date and time.
	 */
	private static void setLocationForDeadlineTask(ArrayList<String> info, String taskName, Task task, int indexOfP,
		String detail, String dateAndTime) {
		if (info.contains(AT)) {//if has location, assign it
			int indexOfAt = info.indexOf(AT);
			Time time = getTime(dateAndTime);
			Date date = getDate(dateAndTime);
			String location = getLocation(info, indexOfAt + 1, indexOfP);
			task.setTaskName(taskName);
			task.setTaskDetails(detail);
			task.setTaskStartDate(date);
			task.setTaskStartTime(time);
			task.setTaskLocation(location);
			task.setTaskType(4);

		} else {//do not have location
			Time time = getTime(dateAndTime);
			Date date = getDate(dateAndTime);
			task.setTaskName(taskName);
			task.setTaskDetails(detail);
			task.setTaskStartDate(date);
			task.setTaskStartTime(time);
			task.setTaskType(4);
		}
	}

	/**
	 * assign priority to deadline task
	 * @param info : ArrayList containing each word of the user input.
	 * @param task : the task object.
	 * @param length : length of the info ArrayList.
	 * @return the index of the keyword priority in the arraylist
	 */
	private static int setPriorityForDeadlineTask(ArrayList<String> info, Task task, int length) {
		int indexOfP;
		if (info.contains(PRIORITY)) {//if has priority, assign it
			indexOfP = info.indexOf(PRIORITY);
			String priority = info.get(indexOfP + 1);
			task.setPriority(getPriority(priority));
		} else {//do not indicate priority, set the priority as 3(lowest priority)
			indexOfP = length;
			task.setPriority(3);
		}
		return indexOfP;
	}

	/**
	 * create the event task
	 * @param taskType : The task type string
	 * @param info : ArrayList containing each word of the user input.
	 * @return an event task
	 */
	public final static Task createEvent(String taskType, ArrayList<String> info) {
		String taskName = taskType + " task";
		Task task = new Task();
		int indexOfFrom = info.indexOf(FROM);
		int indexOfTo = info.indexOf(TO);
		int length = info.size();
		int indexOfP = 0;
		indexOfP = setPriorityForDeadlineTask(info, task, length);

		String detail = getDetail(info, 1, indexOfFrom);
		String startDateAndTime = info.get(indexOfFrom + 1);
		String endDateAndTime = info.get(indexOfTo + 1);
		setLocationForEventTask(info, taskName, task, indexOfP, detail, startDateAndTime, endDateAndTime);
		return task;
	}

	
	/**
	 * assign the location,start time, end time, start date and end date to the event task
	 * @param info : ArrayList containing each word of the user input.
	 * @param taskName : the task name string.
	 * @param task : the task object string.
	 * @param indexOfP : int index of keyword "-p"
	 * @param detail : the string containing the task details.
	 * @param startDateAndTime : the string containing the start date and time.
	 * @param endDateAndTime : the string containing the end date and time.
	 */
	private static void setLocationForEventTask(ArrayList<String> info, String taskName, Task task, int indexOfP,
		String detail, String startDateAndTime, String endDateAndTime) {
		if (info.contains(AT)) {//user indicate the location
			int indexOfAt = info.indexOf(AT);
			Time startTime = getTime(startDateAndTime);
			Date startDate = getDate(startDateAndTime);
			Time endTime = getTime(endDateAndTime);
			Date endDate = getDate(endDateAndTime);
			String location = getLocation(info, indexOfAt + 1, indexOfP);
			task.setTaskName(taskName);
			task.setTaskDetails(detail);
			task.setTaskStartDate(startDate);
			task.setTaskStartTime(startTime);
			task.setTaskEndDate(endDate);
			task.setTaskEndTime(endTime);
			task.setTaskLocation(location);
			task.setTaskType(1);
		} else {//do not indicate the location
			Time startTime = getTime(startDateAndTime);
			Date startDate = getDate(startDateAndTime);
			Time endTime = getTime(endDateAndTime);
			Date endDate = getDate(endDateAndTime);
			task.setTaskName(taskName);
			task.setTaskDetails(detail);
			task.setTaskStartDate(startDate);
			task.setTaskStartTime(startTime);
			task.setTaskEndDate(endDate);
			task.setTaskEndTime(endTime);
			task.setTaskType(1);
		}
	}
	
	/**
	 * create the floating task
	 * @param taskType : the task type string.
	 * @param info : ArrayList containing each word of the user input.
	 * @return the floating task
	 */
	public final static Task createFloating(String taskType, ArrayList<String> info) {
		String taskName = taskType + " task";
		Task task = new Task();
		int length = info.size();
		int indexOfP = 0;
		setLocationForFloatingTask(info, taskName, task, length, indexOfP);
		return task;
	}

	/**
	 * assign the location and location to the floating task
	 * @param info : ArrayList containing each word of the user input.
	 * @param taskName : the task name string
	 * @param task : the task object
	 * @param length : the length of the info ArrayList.
	 * @param indexOfP : int index of keyword "-p"
	 */
	private static void setLocationForFloatingTask(ArrayList<String> info, String taskName, Task task, int length,
		int indexOfP) {
		if (info.contains(AT)) { // info has location
			int indexOfAt = info.indexOf(AT);
			String detail = getDetail(info, 1, indexOfAt);
			indexOfP = setPriorityForDeadlineTask(info, task, length);
			String location = getLocation(info, indexOfAt + 1, indexOfP);
			task.setTaskName(taskName);
			task.setTaskDetails(detail);
			task.setTaskLocation(location);
			task.setTaskType(2);
		} else { // info does not have location
			String detail;
			detail = setPriorityForFloatingTask(info, task, length);
			task.setTaskName(taskName);
			task.setTaskDetails(detail);
			task.setTaskType(2);
		}
	}

	/**
	 * assign the priority to the floating task
	 * @param info : ArrayList containing each word of the user input.
	 * @param task : the task object.
	 * @param length : the length of the info ArrayLIst.
	 * @return the index number of the keyword priority in the arraylist
	 */
	private static String setPriorityForFloatingTask(ArrayList<String> info, Task task, int length) {
		int indexOfP;
		String detail;
		if (info.contains(PRIORITY)) {//has priority, set the priority to the task
			indexOfP = info.indexOf(PRIORITY);
			detail = getDetail(info, 1, indexOfP);
			String priority = info.get(indexOfP + 1);
			task.setPriority(getPriority(priority));
		} else {//do not indicate the priority, set the priority as 3(lowest priority)
			indexOfP = length;
			task.setPriority(3);
			detail = getDetail(info, 1, length);
		}
		return detail;
	}

	/**
	 * create recurring task
	 * @param taskType : the task type string.
	 * @param info : ArrayList containing each word of the user input.
	 * @return a recurring task
	 */
	public final static Task createRecurring(String taskType, ArrayList<String> info) {
		String taskName = taskType + " task";
		Task task = new Task();
		int indexOfFor = info.indexOf(FOR);
		int indexOfP = 0;
		int fre = getFrequency(info.get(1));
		task.setRecurFrequency(fre);
		task.setRecurTime(Integer.parseInt(info.get(indexOfFor + 1)));

		if (info.contains(BY)) {//the recurring task is a deadline task
			createDeadlineRecurringTask(info, taskName, task, indexOfFor);

		} else if (info.contains(FROM)) {//the recurring task is a deadline task
			createEventRecurringTask(info, taskName, task, indexOfFor);
		} else {//the recurring task is a floating task
			createFloatingRecurringTask(info, taskName, task, indexOfFor, indexOfP);
		}

		task.setRecurring(true);
		return task;
	}

	/**
	 * create a floating recurring task
	 * @param info : ArrayList containing each word of the user input.
	 * @param taskName : the task name string.
	 * @param task : the task object.
	 * @param indexOfFor : int index of keyword "for"
	 * @param indexOfP : int index of keyword "-p"
	 */
	private static void createFloatingRecurringTask(ArrayList<String> info, String taskName, Task task, int indexOfFor,
		int indexOfP) {
		String detail;
		if (info.contains(AT)) {//has location information
			int indexOfAt = info.indexOf(AT);
			detail = getDetail(info, 2, indexOfAt);
			String location = getLocation(info, indexOfAt + 1, indexOfP);
			task.setTaskName(taskName);
			task.setTaskDetails(detail);
			task.setTaskLocation(location);
			task.setTaskType(2);

		} else {//do not have location information
			if (info.contains(PRIORITY)) {//indicate priority
				indexOfP = info.indexOf(PRIORITY);
				detail = getDetail(info, 2, indexOfP);
				String priority = info.get(indexOfP + 1);
				task.setPriority(getPriority(priority));
			} else {//do not indicate priority
				indexOfP = indexOfFor;
				detail = getDetail(info, 2, indexOfP);
				task.setPriority(3);
			}
			task.setTaskName(taskName);
			task.setTaskDetails(detail);
			task.setTaskType(2);
		}
	}

	/**
	 * create an event recurring task
	 * @param info : ArrayList containing each word of the user input.
	 * @param taskName : the task name string.
	 * @param task : the task object.
	 * @param indexOfFor : int index of keyword "for"
	 */
	private static void createEventRecurringTask(ArrayList<String> info, String taskName, Task task, int indexOfFor) {
		int indexOfP;
		String detail;
		String dateAndTime;
		String endDateAndTime;
		int indexOfFrom = info.indexOf(FROM);
		int indexOfTo = info.indexOf(TO);
		detail = getDetail(info, 2, indexOfFrom);
		dateAndTime = info.get(indexOfFrom + 1);
		endDateAndTime = info.get(indexOfTo + 1);
		if (info.contains(AT)) {//indicate location
			int indexOfAt = info.indexOf(AT);
			Time startTime = getTime(dateAndTime);
			Date startDate = getDate(dateAndTime);
			Time endTime = getTime(endDateAndTime);
			Date endDate = getDate(endDateAndTime);
			if (info.contains(PRIORITY)) {//indicate priority
				indexOfP = info.indexOf(PRIORITY);
				String priority = info.get(indexOfP + 1);
				String location = getLocation(info, indexOfAt + 1, indexOfP);
				task.setTaskLocation(location);
				task.setPriority(getPriority(priority));
			} else {//do not indicate the priority
				indexOfP = indexOfFor;
				task.setPriority(3);
				String location = getLocation(info, indexOfAt + 1, indexOfFor);
				task.setTaskLocation(location);
			}
			task.setTaskName(taskName);
			task.setTaskDetails(detail);
			task.setTaskStartDate(startDate);
			task.setTaskStartTime(startTime);
			task.setTaskEndDate(endDate);
			task.setTaskEndTime(endTime);

			task.setTaskType(1);
		} else {//do not indicate location
			Time startTime = getTime(dateAndTime);
			Date startDate = getDate(dateAndTime);
			Time endTime = getTime(endDateAndTime);
			Date endDate = getDate(endDateAndTime);
			task.setTaskName(taskName);
			task.setTaskDetails(detail);
			task.setTaskStartDate(startDate);
			task.setTaskStartTime(startTime);
			task.setTaskEndDate(endDate);
			task.setTaskEndTime(endTime);
			task.setTaskType(1);
			indexOfP = setPriorityForDeadlineTask(info, task, indexOfFor);
		}
	}

	/**
	 * create a deadline recurring task
	 * @param info : ArrayList containing each word of the user input.
	 * @param taskName : the task name string.
	 * @param task : the task object.
	 * @param indexOfFor : int index of keyword "for"
	 */
	private static void createDeadlineRecurringTask(ArrayList<String> info, String taskName, Task task,
		int indexOfFor) {
		int indexOfP;
		String detail;
		String dateAndTime;
		int indexOfBy = info.indexOf(BY);
		detail = getDetail(info, 2, indexOfBy);
		dateAndTime = info.get(indexOfBy + 1);
		if (info.contains(AT)) {//indicate location
			int indexOfAt = info.indexOf(AT);
			Time time = getTime(dateAndTime);
			Date date = getDate(dateAndTime);
			if (info.contains(PRIORITY)) {//indicate priority
				indexOfP = info.indexOf(PRIORITY);
				String priority = info.get(indexOfP + 1);
				task.setPriority(getPriority(priority));
				String location = getLocation(info, indexOfAt + 1, indexOfP);
				task.setTaskLocation(location);
			} else {//do not indicate priority
				indexOfP = indexOfFor;
				task.setPriority(3);
				String location = getLocation(info, indexOfAt + 1, indexOfP);
				task.setTaskLocation(location);
			}
			task.setTaskName(taskName);
			task.setTaskDetails(detail);
			task.setTaskStartDate(date);
			task.setTaskStartTime(time);

			task.setTaskType(4);

		} else {//do not indicate location
			Time time = getTime(dateAndTime);
			Date date = getDate(dateAndTime);
			task.setTaskName(taskName);
			task.setTaskDetails(detail);
			task.setTaskStartDate(date);
			task.setTaskStartTime(time);
			task.setTaskType(4);

			indexOfP = setPriorityForDeadlineTask(info, task, indexOfFor);
		}
	}

	/**
	 * get task details from the arraylist
	 * @param info : ArrayList containing each word of the user input.
	 * @param start : the start index of the details.
	 * @param end : the end index of the details.
	 * @return the string of details
	 */
	public static String getDetail(ArrayList<String> info, int start, int end) {
		String detail = "";
		for (int i = start; i < end; i++) {
			detail = detail + " " + info.get(i);
		}
		return detail.trim();
	}

	
	/**
	 * get task location from the arraylist
	 * @param info : ArrayList containing each word of the user input.
	 * @param start : the start index of the location details.
	 * @param end : the end index of the location details.
	 * @return the string of location
	 */
	public static String getLocation(ArrayList<String> info, int start, int end) {
		String location = "";
		for (int i = start; i < end; i++) {
			location = location + " " + info.get(i);
		}
		return location.trim();
	}

	/**
	 * get time from the date and time string
	 * @param dateAndTime : the date and time string.
	 * @return time object
	 */
	public static Time getTime(String dateAndTime) {
		Time time = new Time();
		if (dateAndTime.contains(";")) { // has both time and date
			String dAndT[] = dateAndTime.split(";");
			if (!isTime(dAndT[0])) { // date first then time
				handleDiffTimeFormat(dAndT[1], time);
			} else { // time first then date
				handleDiffTimeFormat(dAndT[0], time);
			}
		} else { // has either time or date
			if (!isTime(dateAndTime)) { // does not have time info
				time = null;
			} else { // only has time
				handleDiffTimeFormat(dateAndTime, time);
			}
		}
		return time;
	}

	/**
	 * deal with different time format
	 * @param timeInfo : the raw time input string.
	 * @param time : the time object.
	 */
	private static void handleDiffTimeFormat(String timeInfo, Time time) {
		if(timeInfo.contains("am")||timeInfo.contains("pm")){
			handleDiffTimeFormatPart2(timeInfo,time);
		} else {
			handleDiffTimeFormatPart1(timeInfo,time);
		}
	}

	/**
	 * handle 4 time format: 12:00  midnight  noon and 1200 or 923
	 * @param timeInfo : the raw time input string
	 * @param time : the time object.
	 */
	private static void handleDiffTimeFormatPart1(String timeInfo,Time time){
		if (timeInfo.contains(":")) {
			String hAndM[] = timeInfo.split(":");
			time.setHour(Integer.parseInt(hAndM[0]));
			time.setMinute(Integer.parseInt(hAndM[1]));
		} else if (timeInfo.toLowerCase().equals(MIDNIGHT)) {
			time.setHour(23);
			time.setMinute(59);
		} else if (timeInfo.toLowerCase().equals(NOON)) {
			time.setHour(12);
			time.setMinute(0);
		} else {
			if (timeInfo.length() == 3) {
				time.setHour(Integer.parseInt(timeInfo.substring(0, 1)));
				time.setMinute(Integer.parseInt(timeInfo.substring(1, 3)));
			} else {
				time.setHour(Integer.parseInt(timeInfo.substring(0, 2)));
				time.setMinute(Integer.parseInt(timeInfo.substring(2, 4)));
			}
		}
	}

	/**
	 * handle the date format with "pm" and "am"
	 * @param timeInfo : the raw time input string.
	 * @param time : the time object.
	 */
	private static void handleDiffTimeFormatPart2(String timeInfo,Time time){
		if (timeInfo.toLowerCase().contains("am")) {
			String h[] = timeInfo.toLowerCase().split("am");
			if(h[0].length()<=2){
				int hour = Integer.parseInt(h[0]);
				if (hour == 12) {
					hour = 0;
				}
				else if (hour < 1 || hour > 12) {
					hour = -1;
				}
				time.setHour(hour);
				time.setMinute(0);
			} else {
				handleDiffTimeFormatPart1(h[0],time);
				if (time.getHour() == 12) {
					time.setHour(0);
				}
				else if (time.getHour() < 1 || time.getHour() > 12) {
					time.setHour(-1);
				}
			}
		} else {
			String h[] = timeInfo.toLowerCase().split("pm");
			if(h[0].length()<=2){
				int hour = Integer.parseInt(h[0]) + 12;
				if (hour == 24) {
					hour = 12;
				}
				else if (hour < 13 || hour > 24) {
					hour = -1;
				}
				time.setHour(hour);
				time.setMinute(0);
			} else {
				handleDiffTimeFormatPart1(h[0],time);
				time.setHour(time.getHour()+12);
				if (time.getHour() == 24) {
					time.setHour(12);
				}
				else if (time.getHour() < 13 || time.getHour() > 24) {
					time.setHour(-1);
				}
			}
		}
}



	/**
	 * get date from the date and time string
	 * @param dateAndTime : the raw date and time string.
	 * @return the date object
	 */
	public static Date getDate(String dateAndTime) {
		Date date = new Date();
		if (dateAndTime.contains(";")) { // has both time and date
			String dAndT[] = dateAndTime.split(";");
			if (!isTime(dAndT[0])) { // date first then time
				handleDiffDateFormat(dAndT[0], date);
			} else { // time first then date
				handleDiffDateFormat(dAndT[1], date);
			}
		} else { // has either time or date
			if (!isTime(dateAndTime)) { // only have date info

				handleDiffDateFormat(dateAndTime, date);
			} else { // does not have date info
				Time t1 = getTime(dateAndTime);
				Time t2 = new Time(Calendar.getInstance().get(Calendar.HOUR_OF_DAY),
					Calendar.getInstance().get(Calendar.MINUTE));
				if (compareTwoTime(t1, t2)) {
					handleDateFormatWithToday(date);
				} else {
					handleDateFormatWithTmr(date);
				}
			}
		}
		return date;
	}

	/**
	 * handle different date format
	 * @param dateInfo : the raw date string.
	 * @param date : the date object.
	 */
	private static void handleDiffDateFormat(String dateInfo, Date date) {
		if (dateInfo.contains("/")) {
			handleDateFormatWithBackSlash(dateInfo, date);		
		} else if(Shortcuts.diffDateFormat(dateInfo).contains(TODAY)) {
			handleDateFormatWithToday(date);
		} else if (Shortcuts.diffDateFormat(dateInfo).contains(TOMORROW)) {
			handleDateFormatWithTmr(date);
		} else if (dates(Shortcuts.diffDateFormat(dateInfo)) != -1) {
			handleDateFormatWithWeekday(dateInfo, date);
		} else {
			handleDateFormatWithDateAndMonth(dateInfo, date);
		}
	}

	/**
	 * handle date format like this: 1st-apr or 11-aug
	 * @param dateInfo : the raw date string.
	 * @param date : the date object.
	 */
	private static void handleDateFormatWithDateAndMonth(String dateInfo, Date date) {
		if (dateInfo.toLowerCase().contains("st")) {
			String dAndM[] = dateInfo.toLowerCase().split("st-");
			dAndM[1] = dAndM[1].trim();
			Calendar cal = Calendar.getInstance();
			if (compareMonth(Integer.parseInt(dAndM[0]),months(Shortcuts.diffDateFormat(dAndM[1]))+1)) {
				date.setDay(Integer.parseInt(dAndM[0]));
				date.setMonth(months(Shortcuts.diffDateFormat(dAndM[1]))+1);
				date.setYear(cal.get(Calendar.YEAR));
			} else {
				cal.add(Calendar.YEAR, 1);
				date.setDay(Integer.parseInt(dAndM[0]));
				date.setMonth(months(Shortcuts.diffDateFormat(dAndM[1]))+1);
				date.setYear(cal.get(Calendar.YEAR));
			}
		} else if (dateInfo.toLowerCase().contains("nd")) {
			String dAndM[] = dateInfo.toLowerCase().split("nd-");
			dAndM[1] = dAndM[1].trim();
			Calendar cal = Calendar.getInstance();
			if (compareMonth(Integer.parseInt(dAndM[0]),months(Shortcuts.diffDateFormat(dAndM[1]))+1)) {
				date.setDay(Integer.parseInt(dAndM[0]));
				date.setMonth(months(Shortcuts.diffDateFormat(dAndM[1]))+1);
				date.setYear(cal.get(Calendar.YEAR));
			} else {
				cal.add(Calendar.YEAR, 1);
				date.setDay(Integer.parseInt(dAndM[0]));
				date.setMonth(months(Shortcuts.diffDateFormat(dAndM[1]))+1);
				date.setYear(cal.get(Calendar.YEAR));
			}
		} else if (dateInfo.toLowerCase().contains("rd")) {
			String dAndM[] = dateInfo.toLowerCase().split("rd-");
			dAndM[1] = dAndM[1].trim();
			Calendar cal = Calendar.getInstance();
			if (compareMonth(Integer.parseInt(dAndM[0]),months(Shortcuts.diffDateFormat(dAndM[1]))+1)) {
				date.setDay(Integer.parseInt(dAndM[0]));
				date.setMonth(months(Shortcuts.diffDateFormat(dAndM[1]))+1);
				date.setYear(cal.get(Calendar.YEAR));
			} else {
				cal.add(Calendar.YEAR, 1);
				date.setDay(Integer.parseInt(dAndM[0]));
				date.setMonth(months(Shortcuts.diffDateFormat(dAndM[1]))+1);
				date.setYear(cal.get(Calendar.YEAR));
			}
		} else if(dateInfo.toLowerCase().contains("th")){
			String dAndM[] = dateInfo.toLowerCase().split("th-");
			dAndM[1] = dAndM[1].trim();
			Calendar cal = Calendar.getInstance();
			if (compareMonth(Integer.parseInt(dAndM[0]),months(Shortcuts.diffDateFormat(dAndM[1]))+1)) {
				date.setDay(Integer.parseInt(dAndM[0]));
				date.setMonth(months(Shortcuts.diffDateFormat(dAndM[1]))+1);
				date.setYear(cal.get(Calendar.YEAR));
			} else {
				cal.add(Calendar.YEAR, 1);
				date.setDay(Integer.parseInt(dAndM[0]));
				date.setMonth(months(Shortcuts.diffDateFormat(dAndM[1]))+1);
				date.setYear(cal.get(Calendar.YEAR));
			}
		} else {
			String dAndM[] = dateInfo.toLowerCase().split("-");
			dAndM[1] = dAndM[1].trim();
			Calendar cal = Calendar.getInstance();
			if (compareMonth(Integer.parseInt(dAndM[0]),months(Shortcuts.diffDateFormat(dAndM[1]))+1)) {
				date.setDay(Integer.parseInt(dAndM[0]));
				date.setMonth(months(Shortcuts.diffDateFormat(dAndM[1]))+1);
				date.setYear(cal.get(Calendar.YEAR));
			} else {
				cal.add(Calendar.YEAR, 1);
				date.setDay(Integer.parseInt(dAndM[0]));
				date.setMonth(months(Shortcuts.diffDateFormat(dAndM[1]))+1);
				date.setYear(cal.get(Calendar.YEAR));
			}
		}
	}

	/**
	 * handle date format like: Monday, Tuesday etc.
	 * @param dateInfo : the raw date string.
	 * @param date : the date object.
	 */
	private static void handleDateFormatWithWeekday(String dateInfo, Date date) {
		Calendar cal = Calendar.getInstance();
		int infoDayOfWeek = dates(Shortcuts.diffDateFormat(dateInfo));
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK);
		if (infoDayOfWeek >= dayOfWeek) {
			cal.add(Calendar.DAY_OF_MONTH, infoDayOfWeek - dayOfWeek);
			date.setDay(cal.get(Calendar.DAY_OF_MONTH));
			date.setMonth(cal.get(Calendar.MONTH) + 1);
			date.setYear(cal.get(Calendar.YEAR));
		} else {
			cal.add(Calendar.DAY_OF_MONTH, infoDayOfWeek - dayOfWeek + 7);
			date.setDay(cal.get(Calendar.DAY_OF_MONTH));
			date.setMonth(cal.get(Calendar.MONTH) + 1);
			date.setYear(cal.get(Calendar.YEAR));
		}
	}

	/**
	 * handle date format like: tmr or tmrw or tomorrow
	 * @param date : the date object.
	 */
	private static void handleDateFormatWithTmr(Date date) {
		Calendar cal = Calendar.getInstance();
		cal.add(Calendar.DAY_OF_MONTH, 1);
		date.setDay(cal.get(Calendar.DAY_OF_MONTH));
		date.setMonth(cal.get(Calendar.MONTH) + 1);
		date.setYear(cal.get(Calendar.YEAR));
	}

	/**
	 * handle date format like: today
	 * @param date : the date object.
	 */
	private static void handleDateFormatWithToday(Date date) {
		Calendar cal = Calendar.getInstance();
		date.setDay(cal.get(Calendar.DAY_OF_MONTH));
		date.setMonth(cal.get(Calendar.MONTH) + 1);
		date.setYear(cal.get(Calendar.YEAR));
	}

	/**
	 * handle date format like: 06/08/2016 or 06/08
	 * @param dateInfo : the raw input date string.
	 * @param date : the date object.
	 */
	private static void handleDateFormatWithBackSlash(String dateInfo, Date date) {
		String dmy[] = dateInfo.split("/");
		date.setDay(Integer.parseInt(dmy[0]));
		date.setMonth(Integer.parseInt(dmy[1]));
		if(dmy.length==3){
			date.setYear(Integer.parseInt(dmy[2]));
		} else {
			if(compareMonth(Integer.parseInt(dmy[0]),Integer.parseInt(dmy[1]))){
				Calendar cal = Calendar.getInstance();
				date.setYear(cal.get(Calendar.YEAR));
			} else{
				Calendar cal = Calendar.getInstance();
				cal.add(Calendar.YEAR, 1);
				date.setYear(cal.get(Calendar.YEAR));
			}
		}
	}

	/**
	 * compare two date, witch only contains month and date
	 * @param date : the date int
	 * @param month : the month int
	 * @return if the date is larger or equal to today's date, return true; or return false 
	 */
	protected static boolean compareMonth(int date, int month){
		Calendar cal = Calendar.getInstance();
		int curDate = cal.get(Calendar.DAY_OF_MONTH);
		int curMonth = cal.get(Calendar.MONTH)+1;
		if(month>curMonth){
			return true;
		} else if(month==curMonth){
			if(date>=curDate){
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}

	/**
	 * Translate the weekday to a number,Sunday to Saturday indicate 1 to 7
	 * @param dateInfo : the raw date string.
	 * @return the integer number
	 */
	protected static int dates(String dateInfo) {
		int a = 0;
		switch (dateInfo) {
			case MONDAY:
			a = 2;
			break;
			case TUESDAY:
			a = 3;
			break;
			case WEDNESDAY:
			a = 4;
			break;
			case THURSDAY:
			a = 5;
			break;
			case FRIDAY:
			a = 6;
			break;
			case SATURDAY:
			a = 7;
			break;
			case SUNDAY:
			a = 1;
			break;
			default:
			a = -1;
			break;
		}
		return a;
	}

	/**
	 * Translate the month to a number, Jan to Dec indicate 0 to 11
	 * @param dateInfo : the raw date string.
	 * @return the integer number
	 */
	protected static int months(String dateInfo) {
		int a = 0;
		switch (dateInfo) {
			case JANUARY:
			a = 0;
			break;
			case FEBRUARY:
			a = 1;
			break;
			case MARCH:
			a = 2;
			break;
			case APRIL:
			a = 3;
			break;
			case MAY:
			a = 4;
			break;
			case JUNE:
			a = 5;
			break;
			case JULY:
			a = 6;
			break;
			case AUGUST:
			a = 7;
			break;
			case SEPTEMBER:
			a = 8;
			break;
			case OCTOBER:
			a = 9;
			break;
			case NOVEMBER:
			a = 10;
			break;
			case DECEMBER:
			a = 11;
			break;
			default:
			a = -1;
			break;
		}
		return a;
	}

	/**
	 * judge if the string is time or date
	 * @param timeInfo : the raw time string input.
	 * @return true if the string is time
	 */
protected static boolean isTime(String timeInfo) {
	if (timeInfo.toLowerCase().contains("am") || timeInfo.toLowerCase().contains("pm")
			|| timeInfo.contains(MIDNIGHT) || timeInfo.contains(NOON) || containsOnlyNumbers(timeInfo) ||
			containsNumbersAndColon(timeInfo)) {
		return true;
	} else {
		return false;
	}
}
	
	protected static boolean containsNumbersAndColon(String str){
		String t[] = str.split(":");
		return containsOnlyNumbers(t[0])&&containsOnlyNumbers(t[1]);
	}


	/**
	 * to check whether the string only contains number
	 * @param str : the string to be checked.
	 * @return true if the string only has number
	 */
	protected static boolean containsOnlyNumbers(String str) {
		for (int i = 0; i < str.length(); i++) {
			if (!Character.isDigit(str.charAt(i)))
				return false;
		}
		return true;
	}

	/**
	 * give 2 time with hour and minute
	 * @param t1 : first time object.
	 * @param t2 : second time object.
	 * @return true if the first time is bigger than the second one
	 */
	protected static boolean compareTwoTime(Time t1, Time t2) {
		int t1TotalM = t1.getHour() * 60 + t1.getMinute();
		int t2TotalM = t2.getHour() * 60 + t2.getMinute();
		if (t1TotalM > t2TotalM) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * get priority from the string
	 * @param p : the priority string input.
	 * @return integer number
	 */
	protected static int getPriority(String p) {
		int n = Integer.parseInt(p);
		if(n>=3){
			return 3;
		} else {
			return n;
		}
	}

	/**
	 * get frequency from the string 
	 * @param fre : the frequency string input.
	 * @return integer number
	 */
	protected static int getFrequency(String fre) {
		if (fre.equals(DAILY)) {
			return 1;
		} else if (fre.equals(WEEKLY)) {
			return 2;
		} else if (fre.equals(MONTHLY)) {
			return 3;
		} else if(fre.equals(YEARLY)){
			return 4;
		} else {
			return -1;
		}
	}
}
```
###### \src\main\parser\CreateTaskTest.java
``` java

import main.resources.Task;
import main.resources.Time;
import main.parser.Parser;
import main.parser.CreateTask;
```
###### \src\main\parser\CreateTaskTest.java
``` java

public class CreateTaskTest {
	
	@Test
	public void testCreateDeadline(){
		String taskType = "deadline";
		String command = "add eating by 20th-Aug;6pm at soc -p 1";
		ArrayList<String> info = Parser.retrieveCommand(command);
		Task task = CreateTask.createDeadline(taskType,info);
		assertEquals(task.getTaskName(),"deadline task");
		assertEquals(task.getTaskDetails(),"eating");
		assertEquals(task.getTaskStartTime().getHour(),18);
		assertEquals(task.getTaskStartTime().getMinute(),0);
		assertEquals(task.getTaskStartDate().getDay(),20);
		assertEquals(task.getTaskStartDate().getMonth(),8);
		assertEquals(task.getTaskStartDate().getYear(),2016);
		assertEquals(task.getTaskLocation(),"soc");
		assertEquals(task.getPriority(),1);
	}

	@Test
	public void testCreateEvent(){
		String taskType = "event";
		String command = "add eating from 20th-Aug;6pm to 21st-Aug;6pm at soc -p 1";
		ArrayList<String> info = Parser.retrieveCommand(command);
		Task task = CreateTask.createEvent(taskType,info);
		assertEquals(task.getTaskName(),"event task");
		assertEquals(task.getTaskDetails(),"eating");
		assertEquals(task.getTaskStartTime().getHour(),18);
		assertEquals(task.getTaskStartTime().getMinute(),0);
		assertEquals(task.getTaskStartDate().getDay(),20);
		assertEquals(task.getTaskStartDate().getMonth(),8);
		assertEquals(task.getTaskStartDate().getYear(),2016);
		
		assertEquals(task.getTaskEndTime().getHour(),18);
		assertEquals(task.getTaskEndTime().getMinute(),0);
		assertEquals(task.getTaskEndDate().getDay(),21);
		assertEquals(task.getTaskEndDate().getMonth(),8);
		assertEquals(task.getTaskEndDate().getYear(),2016);
		
		assertEquals(task.getTaskLocation(),"soc");
		assertEquals(task.getPriority(),1);
	}

	@Test
	public void testCreateFloating(){
		String taskType = "floating";
		String command = "add eating at soc -p 1";
		ArrayList<String> info = Parser.retrieveCommand(command);
		Task task = CreateTask.createFloating(taskType,info);
		assertEquals(task.getTaskName(),"floating task");
		assertEquals(task.getTaskDetails(),"eating");
		assertEquals(task.getTaskLocation(),"soc");
		assertEquals(task.getPriority(),1);
	}

	@Test
	public void testCreateRecurring(){
		String taskType = "recurring";
		String command = "recurring daily eating from 20th-Aug;6pm to 21st-Aug;6pm at soc -p 1 for 3 times";

		ArrayList<String> info = Parser.retrieveCommand(command);
		Task task = CreateTask.createRecurring(taskType,info);
		assertEquals(task.getTaskName(),"recurring task");
		assertEquals(task.getTaskDetails(),"eating");
		
		assertEquals(task.getTaskStartTime().getHour(),18);
		assertEquals(task.getTaskStartTime().getMinute(),0);
		assertEquals(task.getTaskStartDate().getDay(),20);
		assertEquals(task.getTaskStartDate().getMonth(),8);
		assertEquals(task.getTaskStartDate().getYear(),2016);
		
		assertEquals(task.getTaskEndTime().getHour(),18);
		assertEquals(task.getTaskEndTime().getMinute(),0);
		assertEquals(task.getTaskEndDate().getDay(),21);
		assertEquals(task.getTaskEndDate().getMonth(),8);
		assertEquals(task.getTaskEndDate().getYear(),2016);
		assertEquals(task.getTaskLocation(),"soc");
		assertEquals(task.getRecurFrequency(),1);
		assertEquals(task.getPriority(),1);
		assertEquals(task.getRecurTime(),3);
	}

	@Test
	public void testGetDetail(){
		String command = "add eating from 20th-Aug;6pm to 21st-Aug;6pm at soc -p 1";
		ArrayList<String> info = Parser.retrieveCommand(command);
		assertEquals(CreateTask.getDetail(info,1,2),"eating");
	}

	@Test
	public void testGetLocation(){
		String command = "add eating from 20th-Aug;6pm to 21st-Aug;6pm at soc -p 1";
		ArrayList<String> info = Parser.retrieveCommand(command);
		assertEquals(CreateTask.getLocation(info,7,8),"soc");
	}

	@Test
	public void testGetTime(){
		String dateAndTime = "20th-Aug;6pm";
		
		assertEquals(CreateTask.getTime(dateAndTime).getHour(),18);
		assertEquals(CreateTask.getTime(dateAndTime).getMinute(),0);
		
	}

	@Test
	public void testGetDate(){
		String dateAndTime = "20th-Aug;6pm";
	
		assertEquals(CreateTask.getDate(dateAndTime).getDay(),20);
		assertEquals(CreateTask.getDate(dateAndTime).getMonth(),8);
		assertEquals(CreateTask.getDate(dateAndTime).getYear(),2016);
		

	}

	@Test
	public void testGetPriority(){
		String priority = "2";
		assertEquals(CreateTask.getPriority(priority),2);
	}

	@Test
	public void testGetFrequency(){
		String weekly = "weekly";
		assertEquals(CreateTask.getFrequency(weekly),2);
	}

	@Test
	public void testCompareMonth(){
		assertTrue(CreateTask.compareMonth(20,8));
	}

	@Test
	public void testDates(){
		assertEquals(CreateTask.dates("monday"),2);
	}

	@Test
	public void testMonths(){
		assertEquals(CreateTask.months("January"),0);
	}

	@Test
	public void testIsTime(){
		assertTrue(CreateTask.isTime("1230"));
		assertTrue(CreateTask.isTime("1230pm"));
		assertTrue(CreateTask.isTime("12:30pm"));
		assertTrue(CreateTask.isTime("midnight"));
		assertTrue(CreateTask.isTime("noon"));
	}

	@Test
	public void testContainsOnlyNumbers(){
		assertTrue(CreateTask.containsOnlyNumbers("112332"));
		assertFalse(CreateTask.containsOnlyNumbers("sf12"));
	}

	@Test
	public void testCompareTwoTime(){
		Time time1 = new Time(9,30);
		Time time2 = new Time(8,30);
		assertTrue(CreateTask.compareTwoTime(time1,time2));
	}


}
```
###### \src\main\parser\Parser.java
``` java

public class Parser {
	
	private static final String WHITESPACE = " ";
	private static final String FROM = "from";
	private static final String BY = "by";
	private static final String TO = "to";
	private static final String RECURRING = "recurring";
	private static final String COMPLETE  = "complete";
	private static final String UNCOMPLETE  = "uncomplete";
	
	//Feedback strings
	private static final String MSG_FAIL_NUM_FORMAT_EXCEPTION = "Error: \"%1$s\" is an invalid task number.";
	
	private static Feedback feedback;
	
	/**
	 * store the command into an array list
	 * @param inputFromLogic : the string user input.
	 * @return arraylist
	 */
	public final static ArrayList<String> retrieveCommand(String inputFromLogic){
		
		ArrayList<String> contentListForLogic = new ArrayList<String>();
		inputFromLogic = formatInputForValidParsing(inputFromLogic);
		updateList(inputFromLogic, contentListForLogic);		
		return contentListForLogic;
	}
	

	/**
	 * assign the value to some of the attributes in UserInput
	 * @param userInput : the userInput object.
	 * @return userInput
	 */
	public final static UserInput resetUserInput (UserInput userInput){
		feedback = Feedback.getInstance();
		
		ArrayList<String> inputCommand = retrieveCommand(userInput.getRawInput());
		switch (Shortcuts.shortcuts(inputCommand.get(0).toLowerCase())) {
		case "recurring":
			setUserInputForRecuring(userInput, inputCommand);
			break;
		
		case "add":
			setUserInputForAdd(userInput, inputCommand);
			break;

		
		case "delete":
			setUserInputForDelete(userInput, inputCommand);
			break;
			
		case "edit": 
			setUserInputForEdit(userInput, inputCommand);	
			break;	
			
		case "search":
			setUserInputForSearch(userInput, inputCommand);
			break;
		
		case "sort":
			setUserInputForSort(userInput, inputCommand);
			break;
		
		case "home":
			setUserInputForHome(userInput);
			break;
				
		case "undo":
			setUserInputForUndo(userInput);
			break;
			
		case "redo":
			setUserInputForRedo(userInput);
			break;
			
		case "complete":
			setUserInputForComplete(userInput, inputCommand);
			break;
		
		case "uncomplete":
			setUserInputForUncomplete(userInput, inputCommand);
			break;
			
		case "import":
			setUserInputForImport(userInput, inputCommand);
			break;
			
		case "export":
			setUserInputForExport(userInput, inputCommand);
			break;
			
		default:
			userInput.setCommand(userInput.getRawInput());
			break;
		}
		return userInput;

	}


	/**
	 * deal with redo command,assign the "redo" to command
	 * @param userInput : the userInput object.
	 */
	private static void setUserInputForRedo(UserInput userInput) {
		userInput.setCommand("redo");
	}


	/**
	 * deal with undo command, assign the "undo" to command
	 * @param userInput : the userInput object.
	 */
	private static void setUserInputForUndo(UserInput userInput) {
		userInput.setCommand("undo");
	}




	/**
	 * deal with home command, assign the "home" to command
	 * @param userInput : the userInput object.
	 */
	private static void setUserInputForHome(UserInput userInput) {
		userInput.setCommand("home");
	}


	/**
	 * deal with the export command, assign the "exprot" to command and assign the path
	 * @param userInput : the userInput object.
	 * @param inputCommand : the ArrayList containing the command.
	 */
	private static void setUserInputForExport(UserInput userInput, ArrayList<String> inputCommand) {
		userInput.setCommand("export");
		userInput.setPath(inputCommand.get(1));
	}


	/**
	 * deal with the import command, assign the "import" to command and assign the path
	 * @param userInput : the userInput object.
	 * @param inputCommand : the ArrayList containing the command.
	 */
	private static void setUserInputForImport(UserInput userInput, ArrayList<String> inputCommand) {
		userInput.setCommand("import");
		userInput.setPath(inputCommand.get(1));
	}


	/**
	 * deal with the uncomplete command, assign the "uncomplete" to command, and assign value to 
	 * the delete the deleteNumber
	 * @param userInput: the userInput object.
	 * @param inputCommand: the ArrayList containing the command.
	 */
	private static void setUserInputForUncomplete(UserInput userInput, ArrayList<String> inputCommand) {
		userInput.setCommand("uncomplete");
		userInput.setComplete(false);
		ArrayList<int[]> uncompleteList = new ArrayList<int[]>();
		passDeletePart(inputCommand,userInput,uncompleteList);
	}


	/**
	 * deal with the complete command, assign the "complete" to command, and assign value to 
	 * the delete the deleteNumber
	 * @param userInput: the userInput object.
	 * @param inputCommand: the ArrayList containing the command.
	 */
	private static void setUserInputForComplete(UserInput userInput, ArrayList<String> inputCommand) {
		userInput.setCommand("complete");
		userInput.setComplete(true);
		ArrayList<int[]> completeList = new ArrayList<int[]>();
		passDeletePart(inputCommand,userInput,completeList);
	}


	/**
	 * deal with the sort command, assign the "sort" to command, and assign value to 
	 * the searchTerm, sortType
	 * @param userInput: the userInput object.
	 * @param inputCommand: the ArrayList containing the command.
	 */
	private static void setUserInputForSort(UserInput userInput, ArrayList<String> inputCommand) {
		userInput.setCommand("sort");
		int sortType = getNumber(inputCommand.get(1));
		userInput.setSortType(sortType);
	}


	/**
	 * deal with the search command, assign the "search" to command, and assign value to 
	 * the serachTerm and taskList
	 * @param userInput: the userInput object.
	 * @param inputCommand: the ArrayList containing the command.
	 */
	private static void setUserInputForSearch(UserInput userInput, ArrayList<String> inputCommand) {
		String term = inputCommand.get(1);
		userInput.setCommand("search");
		userInput.setSearchTerm(term);
	}


	/**
	 * deal with the edit command, assign the "edit" to command, and assign value to 
	 * the editNumber, startTime, startDate, endTime, endDate, location, details priority and taskToEdit
	 * @param userInput: the userInput object.
	 * @param inputCommand: the ArrayList containing the command.
	 */
	private static void setUserInputForEdit(UserInput userInput, ArrayList<String> inputCommand) {
		userInput.setCommand("edit");
		ArrayList<Integer> editList = new ArrayList<Integer>();
		if(inputCommand.contains("all")){
			userInput.setIsAll(true);
			String type_Num = inputCommand.get(2);
			editList.add(deleteNumber(type_Num));
			userInput.setTaskType(deleteType(type_Num));
			passEditPart(inputCommand,userInput,editList,3);
		} else {
			String type_Num = inputCommand.get(1);
			editList.add(deleteNumber(type_Num));
			userInput.setTaskType(deleteType(type_Num));
			passEditPart(inputCommand,userInput,editList,2);
		}
	}


	/**
	 * deal with the delete command, assign the "delete" command and assign value to the deleteNumber
	 * @param userInput: the userInput object.
	 * @param inputCommand: the ArrayList containing the command.
	 */
	private static void setUserInputForDelete(UserInput userInput, ArrayList<String> inputCommand) {
		userInput.setCommand("delete");
		ArrayList<int[]> deleteList = new ArrayList<int[]>();
		if(inputCommand.contains("all")){
			userInput.setIsAll(true);
			int[] arr = new int[2];
			arr[0] = deleteType(inputCommand.get(2));
			arr[1] = deleteNumber(inputCommand.get(2));
			deleteList.add(arr);
			userInput.setDeleteNumber(deleteList);
		} else {
			passDeletePart(inputCommand,userInput,deleteList);
		}
	}


	/**
	 * deal with the add command, assign the "add" command and assign value to the task attribute
	 * @param userInput: the userInput object.
	 * @param inputCommand: the ArrayList containing the command.
	 */
	private static void setUserInputForAdd(UserInput userInput, ArrayList<String> inputCommand) {
		Task addTask = createTaskForAdd(inputCommand);
		userInput.setTask(addTask);
		userInput.setCommand("add");
	}


	/**
	 * deal with the recurring command, assign the "recurring" command and assign value to the task attribute
	 * @param userInput: the userInput object.
	 * @param inputCommand: the ArrayList containing the command.
	 */
	private static void setUserInputForRecuring(UserInput userInput, ArrayList<String> inputCommand) {
		Task recurringTask = CreateTask.createRecurring(RECURRING, inputCommand);
		userInput.setTask(recurringTask);
		userInput.setCommand("recurring");
	}

	
	/**
	 * create different task type for add command
	 * @param listFromLogic: 
	 * @return a task object
	 */
	public final static Task createTaskForAdd(ArrayList<String> listFromLogic) {
			
			Task task = new Task();
			String taskType = identifyTaskType(listFromLogic);
			
			switch(taskType) {
			case "deadline":
				task = CreateTask.createDeadline(taskType, listFromLogic);
				break;
			case "event":
				task = CreateTask.createEvent(taskType, listFromLogic);
				break;
			case "floating":
				task = CreateTask.createFloating(taskType, listFromLogic);
				break;
			default:
				break;
			}
			return task;
		}
	

	/**
	 * get the string the user typed in and store each words in a right format in 
	 * an array list.
	 * @param inputFromLogic: the raw data of user input
	 * @param contentListForLogic: the ArrayList containing the command.
	 */
	private static void updateList(String inputFromLogic, ArrayList<String> contentListForLogic) {
		
		//for commands: exit, help, undo etc
		if(onlyOneWord(inputFromLogic)) {
			contentListForLogic.add(Shortcuts.shortcuts(inputFromLogic));
		}
		
		else {  
			//splitting first input from logic into 2: (command) (content)
			String content[] = inputFromLogic.split(WHITESPACE);
			for(int i=0; i<content.length; i++){
				if(i==0){
					contentListForLogic.add(Shortcuts.shortcuts(content[0]));
				} else {
					contentListForLogic.add(content[i]);
				}
			}
		}
	}

	/**
	 * identify different task type
	 * @param listFromLogic: the ArrayList containing the command.
	 * @return the string which represent different task type
	 */
	public static String identifyTaskType(ArrayList<String> listFromLogic ) {
		
		if(listFromLogic.contains(RECURRING)) {
			return "recurring";
		}
		else if(listFromLogic.contains(FROM) && listFromLogic.contains(TO)) {
			return "event";
		} 		
		else if(listFromLogic.contains(BY)) {
			return "deadline";
		}
		else {
			return "floating";
		}
	}

	
	/**
	 * differentiate different command for editing
	 * @param command: the attribute you selected
	 * @return integer which represents the corresponding command
	 */
	protected static Integer getNumber(String command){
		feedback = Feedback.getInstance();
		
		int n = -1;
		switch(command.toLowerCase()){
			case "-de":
			case "de"://detail
				n = 1;
				break;
			case "-sd":
			case "sd"://start date
				n = 2;
				break;
			case "-st":
			case "st"://start time
				n = 3;
				break;
			case "-ed":
			case "ed"://end date
				n = 4;
				break;
			case "-et":
			case "et"://end time
				n = 5;
				break;
			case "-l":
			case "l"://location
				n = 6;
				break;
			case "-p":
			case "p"://priority
				n = 7;
				break;
			case "-c"://complete
			case "c":
				n = 8;
				break;
			default:
				break;
		}
		feedback.setSortString(command);
		
		return n;
	} 
	
	/**
	 * find what kind of task you want to delete
	 * @param s: the string of task type and task number
	 * @return the integer number which represent the corresponding type
	 */
	public static int deleteType(String s){
		int type = -1;
		switch(s.substring(0,1).toLowerCase()){
		case "d":
			type = 4;
			break;
		case "e":
			type = 1;
			break;
		case "f":
			type = 2;
			break;
		default:
			break;
		}
		return type;
	}
	
	/**
	 * find the task number user wants to delete
	 * @param s: the string of task type and task number
	 * @return the task number user wants to delete
	 */
	public static int deleteNumber(String s){
		int num = -1;
		try {
			num = Integer.parseInt(s.substring(1,s.length()));
		}
		catch (NumberFormatException e) {
			feedback.setMessage(String.format(MSG_FAIL_NUM_FORMAT_EXCEPTION, s));
		}
		
		return num;
	}
	
	/**
	 * find the next command such like "-st", "-sd" etc.
	 * @param commands:the ArrayList containing the command
	 * @param n:starting position
	 * @return integer which represents the index number of the next command in the array list
	 */
	protected static int findNextCommand(ArrayList<String> commands, int n){//for edit
		int k = -1;
		for(int i=n+1; i<commands.size(); i++){
			if(commands.get(i).toLowerCase().contains("-st")||commands.get(i).toLowerCase().contains("-sd")||commands.get(i).toLowerCase().contains("-et")||commands.get(i).toLowerCase().contains("-ed")||commands.get(i).toLowerCase().contains("-p")||commands.get(i).toLowerCase().contains("-l")
					||commands.get(i).toLowerCase().contains("-de")){
				k = i;
				return k;
			} 
		}
		return k;
	}
	
	
	/**
	 * If the command is delete, then is will assign value to the deleteNumber attribute
	 * @param commands: the ArrayList containing the command
	 * @param userInput: userInput object 
	 * @param list: store the task number 
	 */
	protected static void passDeletePart(ArrayList<String> commands, UserInput userInput, ArrayList<int[]> list){
		for(int i=1; i<commands.size(); i++){
			int[] arr = new int[2];
			arr[0] = deleteType(commands.get(i));
			arr[1] = deleteNumber(commands.get(i));
			list.add(arr);
		}
		userInput.setDeleteNumber(list);
	}
	
	/**
	 * If the command is edit, then this function will help to assign value to
	 * details, start date, start time, end date, end time, location, priority and 
	 * complete attributes
	 * @param commands: 
	 * @param userInput:userInput object
	 * @param list: an array list
	 * @param start: start position
	 */
	protected static void passEditPart(ArrayList<String> commands, UserInput userInput, ArrayList<Integer> list,int start){
		int i = start;
		while(i<commands.size()){
			int n = getNumber(commands.get(i));
			list.add(n);
			int nextI = findNextCommand(commands,i);
			int tempI;
			if(nextI==-1){
				tempI = i;
				i = commands.size();
			} else {
				tempI = i;
				i = nextI;
			}
			switch(n){
			case 1:
				String details = CreateTask.getDetail(commands, tempI+1, i);	
				userInput.setDetails(details);
				break;
			case 2:
				Date startDate = CreateTask.getDate(commands.get(tempI+1));
				userInput.setStartDate(startDate);
				break;
			case 3:
				Time startTime = CreateTask.getTime(commands.get(tempI+1));
				userInput.setStartTime(startTime);
				break;
			case 4:
				Date endDate = CreateTask.getDate(commands.get(tempI+1));
				userInput.setEndDate(endDate);
				break;
			case 5:
				Time endTime = CreateTask.getTime(commands.get(tempI+1));
				userInput.setEndTime(endTime);
				break;
			case 6:
				String location = CreateTask.getLocation(commands, tempI+1, i);
				userInput.setLocation(location);
				break;
			case 7:
				int priority = CreateTask.getPriority(commands.get(tempI+1));
				userInput.setPriority(priority);
				break;
			case 8:
				if(commands.get(tempI+1).equals("COMPLETE")){
					userInput.setComplete(true);
				} else {
					userInput.setComplete(false);
				}		
				break;
			default:
				break;
			}
		}
		userInput.setEdit(list);
		
	}

	/**
	 * removes all unnecessary whitespaces to 1 whitespace
	 * @param input: a string
	 * @return String
	 */
	protected final static String formatInputForValidParsing (String input) {
		return input.replaceAll("\\s+", WHITESPACE).trim();
	}
	/**
	 * check if a string input is only a word
	 * @param input: a string
	 * @return true if it contains only one word
	 */
	protected final static boolean onlyOneWord(String input) {
		if (input.contains(WHITESPACE)) {
			return false;
		}
		else { 
			return true;
		}
	}

	
}
```
###### \src\main\parser\ParserTest.java
``` java

public class ParserTest {

	
	@Test
	public void testDeleteType() {
		String test1 = "d1";
		String test2 = "e2";
		String test3 = "f3";
		assertTrue(Parser.deleteType(test1)==1);
		assertTrue(Parser.deleteType(test2)==2);
		assertTrue(Parser.deleteType(test3)==3);
	}
	
	@Test
	public void testDeleteNumber() {
		String test1 = "d1";
		String test2 = "e2";
		String test3 = "f3";
		assertTrue(Parser.deleteNumber(test1)==1);
		assertTrue(Parser.deleteNumber(test2)==2);
		assertTrue(Parser.deleteNumber(test3)==3);
	}

	@Test
	public void testRetrieveCommand(){

	}

	@Test
	public void testSetUserInputForRedo(){
		
	}

	@Test
	public void testSetUserInputForUndo(){
		
	}

	@Test
	public void testSetUserInputForHome(){
		
	}

	@Test
	public void testSetUserInputForExport(){
		
	}

	@Test
	public void testSetUserInputForImport(){
		
	}

	@Test
	public void testSetUserInputForUncomplete(){
		
	}

	@Test
	public void testSetUserInputForComplete(){
		
	}

	@Test
	public void testSetUserInputForSort(){
		
	}

	@Test
	public void testSetUserInputForSearch(){
		
	}

	@Test
	public void testSetUserInputForEdit(){
		
	}

	@Test
	public void testSetUserInputForDelete(){
		
	}

	@Test
	public void testSetUserInputForAdd(){
		
	}

	@Test
	public void testSetUserInputForRecurring(){
		
	}

	@Test
	public void testIdentifyTaskType(){
		
	}

	@Test
	public void testGetNumber(){
		
	}


	@Test
	public void testFindNextCommand(){
		
	}

	@Test
	public void testFormatInputForValidParsing(){
		
	}

	@Test
	public void testOnlyOneWord(){
		
	}

}
```
###### \src\main\parser\Shortcuts.java
``` java
public class Shortcuts {

	/**
	 * Parses the flexible command inputs
	 * @param command: the raw input string
	 * @return the standard format string.
	 */
	public static String shortcuts(String command) {
		switch (command) {
		// add task commands
		case "add":
		case "a":
		case "create":
		case "c":
			return "add";
		// delete task commands
		case "delete":
		case "del":
		case "d":
			return "delete";
		// edit task commands
		case "edit":
		case "u":
		case "update":
		case "e":
			return "edit";
		// search command
		case "search":
		case "s":
		case "find":
		case "f":
			return "search";
		// recurring task
		case "recurring":
		case "recur":
		case "r":
			return "recurring";
		//undo command
		case "undo":
			return "undo";
		//redo command
		case "redo":
			return "redo";
		//set command
		case "set":
			return "set";
		//complete command
		case "complete":
		case "mark":
		case "done":
		case "finished":
		case "finish":
			return "complete";
		//uncomplete command
		case "incomplete":
		case "uncomplete":
			return "uncomplete";
		default:
			return command;
		}
	}
	
	
	/**
	 * parses flexible date information 
	 * @param dateInfo:date information
	 * @return the standard date format string.
	 */
	public static String diffDateFormat(String dateInfo){
		switch(dateInfo.toLowerCase()){
		//set date as today
		case "today":
			return "today";
			
		//set date as tomorrow
		case "tmrw":
		case "tmr":
		case "tomorrow":
			return "tomorrow";
			
		//set date as monday
		case "mon":
		case "monday":
			return "monday";
			
		//set date as tuesday
		case "tues":
		case "tuesday":
			return "tuesday";
			
		//set date as wednesday
		case "wed":
		case "weds":
		case "wednesday":
			return "wednesday";
			
		//set date as thursday
		case "thur":
		case "thurs":
		case "thursday":
			return "thursday";
			
		//set date as friday
		case "fri":
		case "firday":
			return "friday";
			
		//set date as saturday
		case "sat":
		case "saturday":
			return "saturday";
			
		//set date as sunday
		case "sun":
		case "sunday":
			return "sunday";
			
		//set date as January
		case "january":
		case "jan":
			return "January";
			
		//set date as February
		case "february":
		case "feb":
			return "February";
			
		//set date as March
		case "march":
		case "mar":
			return "March";
			
		//set date as April
		case "april":
		case "apr":
			return "April";
			
		//set date as May
		case "may":
			return "May";
			
		//set date as June
		case "june":
		case "jun":
			return "June";
			
		//set date as July
		case "july":
		case "jul":
			return "July";
			
		//set date as August
		case "august":
		case "aug":
			return "August";
			
		//set date as September
		case "september":
		case "sep":
			return "September";
			
		//set date as October
		case "october":
		case "oct":
			return "October";
			
		//set date as November
		case "november":
		case "nov":
			return "November";
			
		//set date as December
		case "december":
		case "dec":
			return "December";
			
		default:
			return dateInfo;
		}
	}
}
```
###### \src\main\parser\ShortcutsTest.java
``` java
public class ShortcutsTest {
	@Test
	public void testShortcuts() {
	
		//flexi commands for adding a task
		assertTrue(Shortcuts.shortcuts("add").equals("add"));
		assertTrue(Shortcuts.shortcuts("a").equals("add"));
		assertTrue(Shortcuts.shortcuts("create").equals("add"));
		assertTrue(Shortcuts.shortcuts("c").equals("add"));
		assertFalse(Shortcuts.shortcuts("addddddd").equals("add"));
		
		//delete task commands
		assertTrue(Shortcuts.shortcuts("delete").equals("delete"));
		assertTrue(Shortcuts.shortcuts("del").equals("delete"));
		assertTrue(Shortcuts.shortcuts("d").equals("delete"));
		assertFalse(Shortcuts.shortcuts("ddddddd").equals("delete"));

		//search command
		assertTrue(Shortcuts.shortcuts("search").equals("search"));
		assertTrue(Shortcuts.shortcuts("find").equals("search"));
		assertTrue(Shortcuts.shortcuts("s").equals("search"));
		assertTrue(Shortcuts.shortcuts("f").equals("search"));
		
		//recurring task
		assertTrue(Shortcuts.shortcuts("recurring").equals("recurring"));
		assertTrue(Shortcuts.shortcuts("recur").equals("recurring"));
		assertTrue(Shortcuts.shortcuts("r").equals("recurring"));
		
		//redo and undo
		assertTrue(Shortcuts.shortcuts("redo").equals("redo"));
		assertTrue(Shortcuts.shortcuts("undo").equals("undo"));
		
		//set
		assertTrue(Shortcuts.shortcuts("set").equals("set"));
		
		//complete command
		assertTrue(Shortcuts.shortcuts("complete").equals("complete"));
		assertTrue(Shortcuts.shortcuts("mark").equals("complete"));
		assertTrue(Shortcuts.shortcuts("done").equals("complete"));
		assertTrue(Shortcuts.shortcuts("finish").equals("complete"));
		assertTrue(Shortcuts.shortcuts("finished").equals("complete"));
		
		//incomplete command
		assertTrue(Shortcuts.shortcuts("incomplete").equals("uncomplete"));
		assertTrue(Shortcuts.shortcuts("uncomplete").equals("uncomplete"));

		//invalid cases
		assertFalse(Shortcuts.shortcuts("hahaha").equals("invalid command"));
		assertFalse(Shortcuts.shortcuts("abcdefg add adwd").equals("add"));
		
	}
	
	@Test
	public void testDiffDateFormat(){
		//test tomorrow shortcut
		assertTrue(Shortcuts.diffDateFormat("today").equals("today"));
		//test tomorrow shortcut
		assertTrue(Shortcuts.diffDateFormat("tmr").equals("tomorrow"));
		assertTrue(Shortcuts.diffDateFormat("tmrw").equals("tomorrow"));
		assertTrue(Shortcuts.diffDateFormat("tomorrow").equals("tomorrow"));
		
		//test Monday shortcut
		assertTrue(Shortcuts.diffDateFormat("mon").equals("monday"));
		assertTrue(Shortcuts.diffDateFormat("monday").equals("monday"));
		
		//test Tuesday shortcut
		assertTrue(Shortcuts.diffDateFormat("tues").equals("tuesday"));
		assertTrue(Shortcuts.diffDateFormat("tuesday").equals("tuesday"));
		
		//test Wednesday shortcut
		assertTrue(Shortcuts.diffDateFormat("wed").equals("wednesday"));
		assertTrue(Shortcuts.diffDateFormat("wednesday").equals("wednesday"));
				
		//test Thursday shortcut
		assertTrue(Shortcuts.diffDateFormat("thur").equals("thursday"));
		assertTrue(Shortcuts.diffDateFormat("thurs").equals("thursday"));
		assertTrue(Shortcuts.diffDateFormat("thursday").equals("thursday"));	
		
		//test Friday shortcut
		assertTrue(Shortcuts.diffDateFormat("fri").equals("friday"));
		assertTrue(Shortcuts.diffDateFormat("friday").equals("friday"));
		
		//test Saturday shortcut
		assertTrue(Shortcuts.diffDateFormat("sat").equals("saturday"));
		assertTrue(Shortcuts.diffDateFormat("saturday").equals("saturday"));
		
		//test Sunday shortcut
		assertTrue(Shortcuts.diffDateFormat("sun").equals("sunday"));
		assertTrue(Shortcuts.diffDateFormat("sunday").equals("sunday"));
		
		//test January shortcut
		assertTrue(Shortcuts.diffDateFormat("jan").equals("January"));
		assertTrue(Shortcuts.diffDateFormat("january").equals("January"));
		
		//test February shortcut
		assertTrue(Shortcuts.diffDateFormat("feb").equals("February"));
		assertTrue(Shortcuts.diffDateFormat("february").equals("February"));
		
		//test March shortcut
		assertTrue(Shortcuts.diffDateFormat("mar").equals("March"));
		assertTrue(Shortcuts.diffDateFormat("march").equals("March"));
		
		//test April shortcut
		assertTrue(Shortcuts.diffDateFormat("apr").equals("April"));
		assertTrue(Shortcuts.diffDateFormat("april").equals("April"));
		
		//test May shortcut
		assertTrue(Shortcuts.diffDateFormat("may").equals("May"));
		
		//test June shortcut
		assertTrue(Shortcuts.diffDateFormat("jun").equals("June"));
		assertTrue(Shortcuts.diffDateFormat("june").equals("June"));
		
		//test July shortcut
		assertTrue(Shortcuts.diffDateFormat("jul").equals("July"));
		assertTrue(Shortcuts.diffDateFormat("july").equals("July"));
		
		//test August shortcut
		assertTrue(Shortcuts.diffDateFormat("aug").equals("August"));
		assertTrue(Shortcuts.diffDateFormat("august").equals("August"));
		
		//test September shortcut
		assertTrue(Shortcuts.diffDateFormat("sep").equals("September"));
		assertTrue(Shortcuts.diffDateFormat("september").equals("September"));
		
		//test October shortcut
		assertTrue(Shortcuts.diffDateFormat("oct").equals("October"));
		assertTrue(Shortcuts.diffDateFormat("october").equals("October"));
		
		//test November shortcut
		assertTrue(Shortcuts.diffDateFormat("nov").equals("November"));
		assertTrue(Shortcuts.diffDateFormat("november").equals("November"));
		
		//test December shortcut
		assertTrue(Shortcuts.diffDateFormat("dec").equals("December"));
		assertTrue(Shortcuts.diffDateFormat("december").equals("December"));
		
		//invalid cases
		assertFalse(Shortcuts.diffDateFormat("hah").equals("December"));
		assertFalse(Shortcuts.diffDateFormat("decembers").equals("December"));
	}
}
```
###### \src\main\resources\DateTest.java
``` java
public class DateTest {
	@Test
	public void testGetDay(){
		Date date = new Date(5,8,2016);
		assertTrue(date.getDay()==5);
		assertFalse(date.getDay()==6);
	}
	
	
	@Test
	public void testGetMonth(){
		Date date = new Date(5,8,2016);
		assertTrue(date.getMonth()==8);
		assertFalse(date.getMonth()==6);
	}
	
	@Test
	public void testGetYear(){
		Date date = new Date(5,8,2016);
		assertTrue(date.getYear()==2016);
		assertFalse(date.getYear()==16);		
	}
	
	@Test
	public void testDateString(){
		Date date = new Date(5,8,2016);
		assertTrue(date.getDateString().equals("5-8-2016"));
		assertFalse(date.getDateString().equals("ha"));		
	}

	
	
	@Test
	public void testEquals(){
		Date date1 = new Date(5,8,2016);
		Date date2 = new Date(5,8,2016);
		Date date3 = new Date(5,3,2016);
		
		assertTrue(date1.equals(date2));
		assertFalse(date1.equals(date3));
	}
	
	@Test
	public void testIsLeapYear(){
		Date date1 = new Date(5,8,2016);
		Date date2 = new Date(5,8,2017);
		Date date3 = new Date(5,8,2018);
		assertTrue(date1.isLeapYear());
		assertFalse(date2.isLeapYear());
		assertFalse(date3.isLeapYear());
		
		
		
		
	}
}
```
